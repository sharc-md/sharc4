#!/usr/bin/env python3

#----START of calculation class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
class calculation:
    def __init__( self, **kwargs ):
        for key, value in kwargs.items():
            setattr(self,key,value)
#----END of calculation class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


#----START of fragment class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
class fragment:
    def __init__( self, **kwargs ):
        for key, value in kwargs.items():
            setattr(self,key,value)
        #  self.index = index
        return
    def __hash__(self):
        return self.label.__hash__()
#----END of fragment class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


#----START of excitonic_slater_determinant class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
class excitonic_slater_determinant:
    def __init__( self, sites, site_states ):
        if isinstance( site_states, list ):
            self.site_states = {} # list of electronic_state instances
            for state, site in zip( site_states, sites ):
                self.site_states[site] = state
        elif isinstance( site_states, dict ):
            self.site_states = site_states.copy()
        self.Z = sum( [ self.site_states[site].Z for site in sites ] )
        self.M = sum( [ self.site_states[site].M for site in sites ] )
        self.index = None
#----END of excitonic_slater_determinant class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


#----START of excitonic_configuration_state_function class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
class excitonic_configuration_state_function:
    def __init__( self, m, site_states, rcaufbau ):
        self.index = None
        self.multiplicity = m
        self.site_states = site_states 
        self.transpositions = [ (f, s) for f, s in self.site_states.items() if not self.equalZMN( s, rcaufbau[f] ) ] 
        self.ct_rank = sum( [ abs(s.Z-rcaufbau.site_states[f].Z) for (f,s) in self.transpositions ] )
        self.eci_rank = sum( [ 1 for (f,s) in self.transpositions if s.Z == rcaufbau.site_states[f].Z ] )

    def equalZMN( s1, s2 ):
        if s1.M == s2.M and s1.Z == s2.Z and s1.N == s2.N: return True
        return False
#----END of excitonic_configuration_state_function class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


#----START of excitonic_basis class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
class excitonic_basis:
    def __init__( self, **kwargs ):
        self.ESDs = ESDs
        self.ECSFs = ECFSs
        self.U = U
        for i, ESD in enumerate( self.ESDs ):
            ESD.index = i
        for i, ECSF in enumerate( self.ECSFs ):
            ECSF.index = i
        self.relationships = determine_ESD_relationships( self.ESDs )
#----END of excitonic_basis class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


#----START of ECI class--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
class ECI:
    def __init__(self, job, sites ):
        # Input
        self.job = job 
        self.sites = sites
        self.ECIbasis = {}

        # Output
        self.E = {}
        self.Psi = {'ECSF':{},'ESD':{}}
        self.dignostics = {}
        self.PR = {}
        self.mu = {}
        self.soc = {}
        self.grad = {}
        self.nacs = {}
        return

    #----START of ECI.run------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def run(self):
        self.configure()
        self.construct_ECI_basis()                    # Building ECI-CT basis
        self.construct_ECI_Hamiltonain()              # Construct entire ECI-CT Hamiltonian for all multiplicities
        self.calcuate_eigenstates()                   # Diagonalize Hamiltonian matrix for each multiplicity
        self.calculate_properties( QMin.requests )    # Calculate all properties requested by master
        return
    #----END of ECI.run------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

    #----START of ECI.configure------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def configure(self):
        sites = self.sites
        job = self.job

        eci_level = {}
        for rank, value in job.eci_level.items():
            if rank == 0:
                eci_level[0] = value
            else:
                for subset in value:
                    newsubset = set([ site in sites if any([site.label == f for f in subset])])
                    for label in subset:
                        newsubset.append(sites[label])


        # Determine active site pairs for each type of integral
        for fpair in itertools.combinations( sites, 2 ):
            f1,f2 = fpair
            Dmat = [ [ np.linalg.norm( f1.mol.atom_coord(i) - f2.mol.atom_coord(j) ) for j in range(f2.mol.natm) ] for i in range(f1.mol.natm) ] 
            for relationship, thresholds in job.site_pair_thresholds.item():
                activeJ = any( [ Dmat[i][j] < thresholds[0]*(rvdW[f1.mol.atom_symbol(i)] + rvdW[f2.mol.atom_symbol(j)]) 
                                for j in range(f2.mol.natm) for i in range(f1.mol.natm) ] )
                activeK = any( [ Dmat[i][j] < thresholds[1]*(rvdW[f1.mol.atom_symbol(i)] + rvdW[f2.mol.atom_symbol(j)]) 
                                for j in range(f2.mol.natm) for i in range(f1.mol.natm) ] )
                if activeJ: self.active_pairs['J'][tuple(relationship)].append(fpair)
                if activeK: self.active_pairs['K'][tuple(relationship)].append(fpair)

        # Set number of cores
        n = job.nproc
        os.environ["OMP_NUM_THREADS"] = n
        os.environ["OPENBLAS_NUM_THREADS"] = n
        os.environ["BLAS_NUM_THREADS"] = n
        os.environ["MKL_NUM_THREADS"] = n
        os.environ["VECLIB_MAXIMUM_THREADS"] = n
        os.environ["NUMEXPR_NUM_THREADS"] = n

        return
    #----END of ECI.configure------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


    #----START of compare_ESDs------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def compare_ESDs( ESD1, ESD2 ):
        diffs = [ site for site in sites if not ESD1.site_states[site] is ESD2.site_states[site] ]
        ndiffs = len(diffs)
        if ndiffs == 0:
            comparison = { 'relationship' : (0,0) }
        elif ndiffs == 1:
            comparison = { 'relationship' : (0, 1), 'excitons' : diffs[0] }
        elif ndiffs == 2:
            f,g = diffs
            sf1, sg1 = ESD1.site_states[f], ESD1.site_states[g]
            sf2, sg2 = ESD2.site_states[f], ESD2.site_states[g]
            dZf = sf2.Z - sf1.Z
            dZg = sg2.Z - sg1.Z
            if dZf == 0 and dZg == 0:
                comparison = { 'relationship' : (0,2), 'excitons' : diffs }
            elif dZf == 1 and dZg == -1:
                comparison = { 'relationship' : (1,0), 'donor' : f, 'acceptor' : g }
            elif dZf == -1 and dZg == 1:
                comparison = { 'relationship' : (1,0), 'donor' : g, 'acceptor' : f }
            elif dZf == -2 and dZg == 2:
                pass # this requires double-DO, would go to relationship (2,0)
            elif dZf == 2 and dZg == -2:
                pass # this requires double-DO, would go to relationship (2,0) 
        elif ndiffs == 3:
            f, g, h = diffs
            sf1, sg1, sh1 = ESD1.site_states[f], ESD1.site_states[g], ESD1.site_states[h] 
            sf2, sg2, sh2 = ESD2.site_states[f], ESD2.site_states[g], ESD2.site_states[h]
            dZf = sf2.Z - sf1.Z
            dZg = sg2.Z - sg1.Z
            dZg = sh2.Z - sh1.Z
            if dZf == 1 and dZg == -1 and dZh == 0:
                comparison = { 'relationship' : (1,1), 'donors' : f, 'acceptors' : g, 'excitons' : h }
            elif dZf == -1 and dZg == 1 and dZh == 0:
                comparison = { 'relationship' : (1,1), 'donors' : g, 'acceptors' : g, 'excitons' : h }
            elif dZf == 1 and dZg == 0 and dZh == -1:
                comparison = { 'relationship' : (1,1), 'donors' : f, 'acceptors' : h, 'excitons' : g }
            elif dZf == -1 and dZg == 0 and dZh == 1:
                comparison = { 'relationship' : (1,1), 'donors' : h, 'acceptors' : f, 'excitons' : g }
            elif dZf == 0 and dZg == 1 and dZh == -1:
                comparison = { 'relationship' : (1,1), 'donors' : g, 'acceptors' : h, 'excitons' : f }
            elif dZf == 0 and dZg == -1 and dZh == 1:
                comparison = { 'relationship' : (1,1), 'donors' : h, 'acceptors' : g, 'excitons' : f }
            elif dZf == 2 and dZg == -1 and dZh == -1:
                pass # This is (2,0) but with one double-donor and two single-acceptors, e.g. < S0^{0}, S1^{0} S0^{0} | H | S0^{2+} D0^{1-} D3^{1-} > = J - K between double-DO on fragment 1 and a product of DOs on fragments 2 and 3.
            elif dZf == -2 and dZg == 1 and dZh == 1:
                pass # Similar to upper 
            elif dZf == -1 and dZg == 2 and dZh == -1:
                pass # Similar to upper 
            elif dZf == 1 and dZg == -2 and dZh == 1:
                pass # Similar to upper 
            elif dZf == -1 and dZg == -1 and dZh == 2:
                pass # Similar to upper 
            elif dZf == 1 and dZg == 1 and dZh == -2:
                pass # Similar to upper 
        #elif ndiffs == 4:
        #    f, g, h, m = diffs
        #    sf1, sg1, sh1, sm1 = ESD1.site_states[f], ESD1.site_states[g], ESD1.site_states[h], ESD1.site_states[m] 
        #    sf2, sg2, sh2, sm2 = ESD2.site_states[f], ESD2.site_states[g], ESD2.site_states[h], ESD2.site_states[m]
        #    dZf = sf2.Z - sf1.Z
        #    dZg = sg2.Z - sg1.Z
        #    dZh = sh2.Z - sh1.Z
        #    dZm = sm2.Z - sm1.Z
        #    dZall = np.array( [ dZf, dZg, dZh, dZm ], dtype=int )
        #    donors = np.nonzero( dZall == 1 )[0]
        #    accpetors = np.nonzero( dZall == -1 )[0]
        #    if len(donors) == 2 and len(acceptors) == 2: # Double charge transfer with two donors and two acceptors
        #        relationships[(2,0)].append( { 'donors': diffs[donors], 'acceptors' : diffs[acceptors], 'ESDs': (ESD1,ESD2) } )
        else:
            return None
        return comparison
    #----END of compare_ESDs------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


    #----START of determine_ESD_relationships------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def determine_ESD_relationships( self, ESDs ):
        job = self.job
        relationships = {(0,0):[], (0,1):[], (0,2):[], (1,0):[], (1,1):[], (2,0):[]} 
        for i1, ESD1 in enumerate( ESDs ):
            for i2, ESD2 in enumerate( ESDs[i1:] ):
                comparison = compare_ESDs( ESD1, ESD2 )
                rel =  comparison['relationship']
                del comparison['relationship']
                comparison['ESDs'] = ( ESD1, ESD2 )
                comparison['indices'] = (i1,i2)
                relationships[rel].append( comparison )
        return relationships
    #----END of determine_ESD_relationships------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


    #----START of ECI.construct_excitonic_basis------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def construct_excitonic_basis( self, c ):
        allESDs = get_aufbaus( c, self.sites )
        allESDs = make_excitations( self, allESDs )
        allESDs = overlap_criterion( self, allESDs )
        for m in self.job.multiplicities:
            ESDs, ECSFs, U = spin_adapt( m, allESDs )
            self.ECIbasis[m] = excitonic_basis( ESDs, ECFSs, U )
    #----END of ECI.construct_excitonic_basis------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    
    #----START of ECI.get_aufbaus------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def get_aufbaus(c, sites):
        nf = len(sites)
        aufbaus = []
        aufbaustates = [ site.aufbaustates for site in sites ]
        aufbaus = list(itertools.product(*aufbaustates)) 
        ESDs = [ excitonic_slater_determinant(aufbau) for aufbau in aufbaus ]
    
        # Take only those with correct charge
        ESDs = [ ESD for ESD in ESDs if ESD.Z == c ]
        if len( ESDs ) == 0:
            raise ValueError(' No aufbau ESD for the full-system charge '+str(c)+' does not actually have that charge. Probably sum of refstate charges for this full-system charge is not equal to that charge.' )
    
        # Take only those with requested CT level
        status = []
        for aufbau in ESDs:
            good = False
            plus, minus = 0, 0
            for f in sites:
                deltaZ = aufbau.site_statates[f].Z - f.refcharge
                if deltaZ > 0: plus += deltaZ
                if deltaZ < 0: minus += deltaZ
            if abs(plus) == abs(minus):
                if plus in job.ct_level:
                    good = True
            status.append( good )
        ESDs = [ ESD for i, ESD in enumerate(ESDs) if status[i] ]
    
        print(' Number of aufbau ESDs with correct charge and CT-level = '+str(len(ESDs)))
        return ESDs
    #----END of ECI.get_aufbaus------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    

    #----START of ECI.make_excitations------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def make_excitations( self, c, ESDs )
        job = self.job
        sites = self.sites
        excitedESDs = []
        for aufbau in ESDs:
            for level in job.eci_level:
                for fc in itertools.combinations( sites, level ):
                    fcomb = list(fc)
                    site_state_lists = [ [ s for s in f.states if s.Z == aufbau.site_states[f].Z and not s in f.aufbaustates ] for f in fcomb ]
                    excitations = list(itertools.product(*site_state_lists))
                    for e in excitations:
                        site_states = [ aufbau.site_states[f] for f in sites if not f in fcomb else e[fcomb.index(f)] ]
                        ESD = excitonic_slater_determinant( site_states )
                        if not ESD in excitedESDs: excitedESDs.append(ESD) 
        ESDs = ESDs + excitedESDs
        print(' Number of aufbau and excited ESDs with correct charge and CT-level = '+str(len(ESDs)))
        return ESDs                        
    #----END of ECI.make_excitations------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    
    
    #----START of ECI.overlap_criterion------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def overlap_criterion( self, ESDs ):
        job = self.job
        sites = self.sites

        # Get site-state pairs that overlap too much
        pairs_to_expell = {}
        for fpair in itertools.combinations( sites, 2 ):
            pairs_to_expell[fpair] = []
            f1, f2 = fpair
            dimer = merge_moles( f1.mol, f2.mol )
            SAO = dimer.intor('int1e_ovlp')[ 0:f1.mol.nao:, f1.mol.nao: ]
    
            # Refstate overlap
            rho1 = f1.rho[(f1.refstates[0], f1.refstates[0], 'aa')]
            rho2 = f2.rho[(f2.refstates[0], f2.refstates[0], 'aa')]
            Sref = np.einsum( 'ij,kl,il,jk', rho1, rho2, SAO, SAO, optimize=['einsum_path', (0, 2), (0, 1), (0, 1)] ) 
            rho1 = f1.rho[(f1.refstates[0], f1.refstates[0], 'bb')]
            rho2 = f2.rho[(f2.refstates[0], f2.refstates[0], 'bb')]
            Sref += np.einsum( 'ij,kl,il,jk', rho1, rho2, SAO, SAO, optimize=['einsum_path', (0, 2), (0, 1), (0, 1)] ) 
            Sref = 1. - Sref
            
            for s1 in f1.states:
                for s2 in f2.states:
                    if s1.Z == s2.Z:
                        rho1 = f1.rho[(s1, s1, 'aa')]
                        rho2 = f2.rho[(s2, s2, 'aa')]
                        S = np.einsum( 'ij,kl,il,jk', rho1, rho2, SAO, SAO, optimize=['einsum_path', (0, 2), (0, 1), (0, 1)] ) 
                        rho1 = f1.rho[(s1, s1, 'bb')]
                        rho2 = f2.rho[(s2, s2, 'bb')]
                        S += np.einsum( 'ij,kl,il,jk', rho1, rho2, SAO, SAO, optimize=['einsum_path', (0, 2), (0, 1), (0, 1)] ) 
                        S = 1. - S
                        S /= Sref
                        if S < job.tO:
                            pairs_to_expell[(f1,f2)].append( (s1,s2) )
    
        # Remove ESDs containing at least one such site-state pair
        toremove = []
        for ESD in ESDs:
            for (f1,f2), (s1,s2) in pairs_to_expell.items():
                if ESD.site_states[f1] is s1 and ESD.site_states[f2] is s2:
                    toremove.append( ESD )
                    continue
        ESDs = [ ESD for ESD in ESDs if not ESD in toremove ]
        print(' Number of ESDs after overlap-criterion = '+str(len(ESDs)))
        return ESDs                    
    #----END of ECI.overlap_criterion------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    

    #----START of ECI.spin_adapt------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def spin_adapt( m, allESDs ):
        ESDs = [ ESD for ESD in allESDs if ESD.MSx2 == (m-1) ]
        print(' Constructed '+str(len(ESDs))+ ' ESDs with MS = ',str(ESDs[0].MS))
        S2mat = calculate_S2mat( ESDs )
        S2val, U = np.linalg.eigh( S2mat, 'U' )
        mults = ( np.sqrt(4.*abs(S2val)) + 1. ).astype(int)
        if not m in mults:
            raise ValueError(f"  No excitonic CSF that can be generated from given states and chosen ECI expansion corresponds to the requested multiplicity {m} ( possible multiplicities =  {mults}).r")
        ECSFs_IDs = np.nonzero( mults == m )[0]
        U = np.take( U, ECSFs_IDs, axis=1 )
        ESD_IDs = [ i for i in range( np.shape(U)[0] ) if np.any( np.abs(U[i,:]) > 0.01 ) ]
        U = np.take( U, ESDs_IDs, axis=0 )
        ESDs = ESDs[ESD_IDs]
        ECSFs = []
        for i in range( np.shape(U)[1] ):
            ESD_ID = np.nonzero( np.abs( U[:,i] ) > 0.01 )[0][0]
            ESD = ESDs[ESD_ID] 
            ECSFs.append( excitonic_configuration_state_function( m, ESD ) )
        print(' Constructed '+str(len(ECSFs))+' ECSFs of multiplicity '+str(m)+', spanned by '+str(len(ESDs))+' ESDs')
        return ESDs, ECSFs, U
    #----END of ECI.spin_adapt------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

    
    #----START of ECI.calculate_S2mat------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def calculate_S2mat( job, sites, ESDs, relationship ):
        nESD = len( ESDs )
        S2mat = np.zeros( (nESD, nESD) )
        # Diagonal
        for i, ESD in enumerate( ESDs ):
            S2mat[i,i] += sum( [ ESD.site_states[f].S * ( ESD.site_states[f].S + 1. ) for f in sites ] ) 
            S2mat[i,i] += 2.*sum( [ ESD.site_states[f].MS*ESD.site_states[f].MS for i, f in enumerate( sites ) for j, g in enumerate( sites[i:] ) ] )
            # Off-diagonal
        relationships = determine_ESD_relationships( ESDs )
        for pair in relationships['(0,2)']:
            ESD1, ESD2 = pair['ESDs']
            f, g = pair['excitons']
            sf1, sg1 = ESD1.site_states[f], ESD1.site_states[g]
            sf2, sg2 = ESD2.site_states[f], ESD2.site_states[g]
            if sf1.symbol_without_ms == sf1.symbol_without_ms and sg1.symbol_without_ms == sg2.symbol_without_ms:
                if sf1.MSx2 == sf2.MSx2 - 2 and sg1.MSx2 == sg2.MSx2 + 2:
                    x = sf1.S*( sf1.S + 1. ) - sf1.MS*( sf1.MS + 1. ) 
                    y = sg1.S*( sg1.S + 1. ) - sg1.MS*( sg1.MS - 1. ) 
                    S2mat[pair['indices'][0],pair['indices'][1]] = math.sqrt(x)*math.sqrt(y)
                elif sf1.MSx2 == sf2.MSx2 + 2 and sg1.MSx2 == sg2.MSx2 - 2: 
                    x = sf1.S*( sf1.S + 1. ) - sf1.MS*( sf1.MS - 1. ) 
                    y = sg1.S*( sg1.S + 1. ) - sg1.MS*( sg1.MS + 1. ) 
                    S2mat[pair['indices'][0],pair['indices'][1]] = math.sqrt(x)*math.sqrt(y)
        return S2mat
    #----END of ECI.calculate_S2mat------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
                    


    #----START of ECI.merge_moles------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def merge_moles( m1, m2 ):
        for m in moles:
            pure_symbols = [ m.atom_pure_symbol(j) for j in range(m.natm) ] 
            atom = m._atom
            basis = m._basis
            for j in range(m.natm):
                na += 1
                allatoms.append( ( pure_symbols[j]+str(na),  atom[j][1] ) )
                allbasis[pure_symbols[j]+str(na)] = basis[atom[j][0]]

    #----END of ECI.merge_moles------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


    #----START of ECI.calculate_Fmat------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def calculate_Fmat( nucs, mol ):
        F = np.zeros((mol.nao, mol.nao))
        for nuc in nucs:
            Z, R = nuc
            mol.set_rinv_orig(R)
            F += Z*mol.intor('int1e_rinv')
        return F
    #----END of ECI.calculate_Fmat------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


    #----START of ECI.calculate_Ltensor------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def calculate_Ltensor( moles, auxbasis ):
        starts = {}
        ends = {}
        supermolecule = None
        for mol in moles:
            if not mol in starts.keys():
                starts[mol] = sum( [ m.nao for m in starts.keys() ] )
                ends[mol] = starts[mol] + mol.nao 
                supermolecule = merge_moles( supermolecule, mol )

        Lraw = pyscf.df.incore.cholesky_eri(supermolecule, auxbasis=auxbasis)
        L = pyscf.lib.unpack_tril(Lraw)
        L1 = L[:,starts[moles[0]]:ends[moles[0]],starts[moles[1]]:ends[moles[1]]] 
        L2 = L[:,starts[moles[2]]:ends[moles[2]],starts[moles[3]]:ends[moles[3]]] 
        return L1, L2
    #----END of ECI.calculate_Ltensor------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


    #----START of ECI.calculate_Gtensor------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def calculate_Gtensor( moles, auxbasis ):
        starts = {}
        ends = {}
        supermolecule = None
        for mol in moles:
            if not mol in starts.keys():
                starts[mol] = sum( [ m.nbas for m in starts.keys() ] )
                ends[mol] = starts[mol] + mol.nbas 
                supermolecule = merge_moles( supermolecule, mol )

        G = supermolecule.intor('int2e',
                                shls_slice=( starts[moles[0]], ends[moles[0]], 
                                            starts[moles[1]], ends[moles[1]], 
                                            starts[moles[2]], ends[moles[2]], 
                                            starts[moles[3]], ends[moles[3]] ) )
        return G
    #----END of ECI.calculate_Gtensor------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


    #----START of ECI.calculate_Hmat------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def calculate_Hmat( self ):
        job = self.job
        ECIbasis = self.ECIbasis
        sites = self.sites
        H = self.H
        J = self.J
        K = self.K

        ECI_integrals = get_ECI_integrals( job, ECIbasis, sites )

        integrals = [ integral for integral in ECI_integrals if integral.ECItype == 'ECI_V' and integral.kind == '<AO|1/(r-R)|AO>' ]
        N = len(integrals)
        if N > 0:
            print(' Calculating ECI V-integrals of <AO|1/(r-R)|AO> type (# = '+str(N)+')...')
            nucs_frags = set( [ ( integral.nucs, integral.f ) for integral in integrals ] )
            for nucs, f in nucs_frags:
                subintegrals = [ integral for integral in integrals if integral.nucs == nucs and integral.f is f ]
                rhos = np.array( [ integral.rho for integral in subintegrals ] )
                locs = [ integral.loc for integral in subintegrals ]
                Fmat = calculate_Fmat( nucs, f.mol )
                values = np.einsum( 'ij,nij->n', Fmat, rhos, optimize=['einsum_path', (0,1)] ) 
                for i, (mult,row,column) in enumerate(locs):
                    J[mult][row,column] -= values[i]


        integrals = [ integral for integral in ECI_integrals if integral.ECItype == 'ECI_J' and integral.kind == '<AO,AO|1/r|AO,AO>' ]
        N = len(integrals)
        if N > 0:
            print(' Calculating ECI J-integrals of <AO,AO|1/r|AO,AO> type (# = '+str(N)+')...')
            fpairs = set( [ (i.f, i.g) for i in integrals ] )
            for (f,g) in fpairs:
                subintegrals = [ i for i in integrals if i.f is f and i.g is g ]
                rho1s = np.array( [ i.rho1 for i in subintegrals ] )
                rho2s = np.array( [ i.rho2 for i in subintegrals ] )
                locs = [ i.loc for i in subintegrals ]
                if job.ri:
                    L1, L2 = calculate_Ltensor( [ f.mol, f.mol, g.mol, g.mol ], job.auxbasis )
                    values = np.einsum( 'nij,mij,mkl,nkl->n', rho1s, L1, L2, rho2s, optimize=['einsum_path', (0, 1), (0, 1), (0, 1)] )
                else:
                    G = calculate_Gtensor( f.mol, f.mol, g.mol, g.mol ) 
                    values = np.einsum( 'nij,ijkl,nkl->n', rho1s, G, rho2s, optimize=['einsum_path', (0, 1), (0, 1)] )
                for i, (mult,row,column) in enumerate(locs):
                    J[mult][row,column] += values[i]

        integrals = [ integral for integral in ECI_integrals if integral.ECItype == 'ECI_K' and integral.kind == '<AO,AO|1/r|AO,AO>' ]
        N = len(integrals)
        if N > 0:
            print(' Calculating ECI K-integrals of <AO,AO|1/r|AO,AO> type (# = '+str(N)+')...')
            fpairs = set( [ (i.f, i.g) for i in integrals ] )
            for (f,g) in fpairs:
                subintegrals = [ i for i in integrals if i.f is f and i.g is g ]
                rho1s = np.array( [ i.rho1 for i in subintegrals ] )
                rho2s = np.array( [ i.rho2 for i in subintegrals ] )
                locs = [ i.loc for i in subintegrals ]
                if job.ri:
                    L1, L2 = calculate_Ltensor( f.mol, g.mol, f.mol, g.mol, job.auxbasis )
                    values = np.einsum( 'nij,mil,mjk,nkl->n', rho1s, L1, L2, rho2s, optimize=['einsum_path', (0, 1, 2, 3)] )
                else:
                    G = calculate_Gtensor( f.mol, g.mol, f.mol, g.mol ) 
                    values = np.einsum( 'nij,iljk,nkl->n', rho1s, G, rho2s, optimize=['einsum_path', (0, 1), (0, 1)] )
                for i, (mult,row,column) in enumerate(locs):
                    K[mult][row,column] += values[i]

        integrals = [ integral for integral in ECI_integrals if integral.ECItype == 'SCT_V' ]
        N = len(integrals)
        if N > 0:
            print(' Calculating SCT V-integrals (# = '+str(N)+')...')
            frags_nucs_frags = set( [ ( i.f1, i.nucs, i.f2 ) for i in integrals ] )
            for (f1, nucs, f2) in frags_nucs_frags:
                subintegrals = [ i for i in integrals if i.f1 is f1 and i.nucs == nucs and i.f2 is f2 ]
                Tmat = self.merge_moles( f1.mol, f2.mol ).intor('int1e_kin')[0:f1.mol.nao,f2.mol.nao:]  
                Fmat = calculate_Fmat( nucs, self.merge_moles( f1.mol, f2.mol ) )[0:f1.mol.nao,f2.mol.nao:] 
                hmat = Tmat + Fmat
                phi1s = np.array( [ i.phi1 for i in subintegrals ] )
                phi2s = np.array( [ i.phi2 for i in subintegrals ] )
                locs = [ i.loc for i in subintegrals ]
                prefactors = [ i.prefactor for i in subintegrals ]
                values = np.einsum( 'ni,ij,nj->n', phi1s, hmat, phi2s, optimize=['einsum_path', (0,1), (0,1)] )
                for i, (mult,row,column) in enumerate(locs):
                    J[mult][row,column] -= values[i]*prefactors[i]

                    
        integrals = [ integral for integral in ECI_integrals if integral.ECItype == 'SCT_JK' ]
        N = len(integrals)
        if N > 0:
            print(' Calculating SCT J- and K-integrals together (# = '+str(N)+')...')
            fgh = set( [ ( i.f1, i.f2, i.f3 ) for i in integrals ] )
            for (f, g, h) in fgh:
                subintegrals = [ i for i in integrals if i.f1 is f and i.f2 is g and i.f3 is h ]
                Jintegrals = [ i for i in subintegrals if i.which == 'J' ]
                Kintegrals = [ i for i in subintegrals if i.which == 'K' ]
                Jphi1s = np.array( [ i.phi1 for i in Jintegrals ] )
                Jphi2s = np.array( [ i.phi2 for i in Jintegrals ] )
                Jrhos = np.array( [ i.rho for i in Jintegrals ] )
                Jlocs = [ i.loc for i in Jintegrals ]
                Jprefactors = [ i.prefactor for i in Jintegrals ]
                Kphi1s = np.array( [ i.phi1 for i in Kintegrals ] )
                Kphi2s = np.array( [ i.phi2 for i in Kintegrals ] )
                Krhos = np.array( [ i.rho for i in Kintegrals ] )
                Klocs = [ i.loc for i in Kintegrals ]
                Kprefactors = [ i.prefactor for i in Kintegrals ]
                if job.ri:
                    L1, L2 = calculate_Ltensor( f.mol, g.mol, h.mol, h.mol, job.auxbasis )
                    Jvalues = np.einsum( 'ni,nj,mij,mkl,nkl->n', Jphi1s, Jphi2s, L1, L2, Jrhos, optimize=['einsum_path', (0, 1), (0, 3), (0, 1), (0, 1)] ) 
                    Kvalues = np.einsum( 'ni,nj,mil,mjk,nkl->n', Jphi1s, Jphi2s, L1, L2, Jrhos, optimize=['einsum_path', (0, 1), (0, 1, 2, 3)] ) 
                else:
                    G = calculate_Gtensor( f.mol, g.mol, h.mol, h.mol )
                    Jvalues = np.einsum( Jphi1s, Jphi2s, G, Jrhos, 'ni,nj,ijkl,nkl->n', optimize=['einsum_path', (2, 3), (0, 2), (0, 1)]) 
                    Kvalues = np.einsum( Jphi1s, Jphi2s, G, Jrhos, 'ni,nj,iljk,nkl->n', optimize=['einsum_path', (2, 3), (0, 2), (0, 1)]) 
                for i, (mult,row,column) in enumerate(Jlocs):
                    J[mult][row,column] += Jvalues[i]*Jprefactors[i]
                for i, (mult,row,column) in enumerate(Kintegrals['locs']):
                    K[mult][row,column] += Kvalues[i]*Kprefactors[i]

        print(' Summing up J- and K-matrices, adding site energies and VNN to the diagonal, and rotating J-, K-, and H-matrices to the basis of ECSFs...')
        VNN = sum( [ 
                    ( float( f.mol.atom_charge(i) )*float( g.mol.atom_charge(j) )
                    - float( f.mol.atom_charge(i) )*g.Q[j]
                    - float( g.mol.atom_charge(j) )*f.Q[i] 
                     )/np.linalg.norm( f.mol.atom_coord(i) - g.mol.atom_coord(j) )
                    for ( f, g ) in job.active_integrals['J'][(0,0)]
                    for i in range(f.mol.natm) for j in range(g.mol.natm)
                    ] 
                  )
        for m in job.multiplicities:
            J[m] += VNN*np.identity( np.shape(J[m])[0] )
            H[m] = J[m] - K[m]

            for i, ESD in enumerate( ECIbasis[m].ESDs ):
                H[m][i,i] += sum( [ site.find_H_mel( ESD.site_states[f] , ESD.site_states[f] ) for f, site in enumerate( sites ) ] )

            H[m] = H[m] + H[m].T - np.diag( np.diag( H[m] ) )
            J[m] = J[m] + J[m].T - np.diag( np.diag( J[m] ) )
            K[m] = K[m] + K[m].T - np.diag( np.diag( K[m] ) )

            H[m] = ECIbasis[m].U.T @ H[m] @ ECIbasis[m].U 
            J[m] = ECIbasis[m].U.T @ J[m] @ ECIbasis[m].U 
            K[m] = ECIbasis[m].U.T @ K[m] @ ECIbasis[m].U 
        return
    #----END of ECI.calculate_Hmat------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

    def calculate_eigenstates( self ):
        job = self.job
        ECIbasis = self.ECIbasis
        for m in job.multiplicities:
            self.Psi['ECSF'][m], self.E[m] = np.eigh( self.H[m] )
            self.Psi['ESD'][m] = self.ECIbasis[m].U.T @ self.Psi['ECSF'][m]
            nstates = len( ECIbasis[m].ECSFs)
            self.diagnostics[m] = np.zeros( ( max(job.ct_level), max(job.eci_level), nstates ) )
            C2 = np.zeros( nstates )
            C4 = np.zeros( nstates )
            for i, ECSF in enumerate( self.ECIbasis[m].ECSFs ):
                self.diagnostics[m][ECSF.ct_level,ECSF.eci_level,:] += self.Psi['ECSF'][i,:]**2
                C2 += self.Psi['ECSF'][i,:]**2
                C4 += self.Psi['ECSF'][i,:]**4
            self.PR[m] = np.divide(C2,C4)
        return

    def calculate_properties( self, requiests ):
        if 'dm' in requests:
            for m in self.job.multiplicities:
                self.mu[m] = calculate_mu( self )
        if 'grad' in requests:
            self.mu[job.grad['m']] = calculate_dE( self )

    class ECI_integral():
        def __init__( self, **kwargs ):
            self.__dict__.update(kwargs)
        
    def get_ECI_integrals( job, ECIbasis, sites ):
        ECI_integrals = { 'ECI_V': { '<AO|1/(r-R)|AO>': {}, '<DME|1/(r-R)>': {} },
                          'ECI_J': { '<AO,AO|1/r|AO,AO>': {}, '<AO,AO|1/r|DME>': {}, '<DME|1/r|DME>': {} },
                          'ECI_K': {},
                          'SCT_V': {},
                          'SCT_JK': {}
                             }

        ECI_integrals = []

        for m in job.multiplicities:
            ESDs = ECIbasis[m].ESDs
            relationship = ECIbasis[m].relationship

            #-----Start of relationship[(0,0)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            for pair in relationship[(0,0)]:
                ESD = pair['ESD'][0]
                index = ESD.index
                # V-integrals
                for f in sites:
                    nucs = [ ( g.mol.atom_charge(i) - g.Q[i], g.mol.atom_coord(i) ) for g in sites for i in range(g.mol.natm) 
                            if (f,g) in self.active_integrals['J'][(0,0)] ]
                    if len(nucs) > 0:
                        if f.densrep == 'AO':
                            rho = f.find_rho( ESD.site_states[f], ESD.site_states[f], 'tot' )
                            integral = ECI_integral( m=m, loc=(index,index), ECItype='ECI_V', pattern='<AO|1/(r-R)|AO>', f=f, nucs=nucs, rho=rho ) 
                            ECI_integrals.append( integral )
                        elif site.densrep == 'DME':
                            dme = site.find_dme( ESD.site_states[f], ESD.site_states[f] )
                            integral = ECI_integral( m=m, loc=(index,index), ECItype='ECI_V', pattern='<DME|1/(r-R)>', f=f, nucs=nucs, dme=dme ) 
                            ECI_integrals.append( integral )
                # J-integrals
                for (f,g) in self.active_integrals['J'][(0,0)]:
                    if f.densrep == 'AO' and g.densrep == 'AO':
                        rho1 = f.find_rho( ESD.site_states[f], ESD.site_states[f], 'tot' ) 
                        rho2 = g.find_rho( ESD.site_states[g], ESD.site_states[g], 'tot' ) 
                        integral = ECI_integral( m=m, loc=(index,index), ECItype='ECI_J', pattern='<AO,AO|1/r|AO,AO>', f1=f, f2=g, rho1=rho1, rho2=rho2 ) 
                        ECI_integrals.append( integral )
                # K-integrals
                for (f,g) in self.active_integrals['J'][(0,0)]:
                    rho1 = f.find_rho( ESD.site_states[f], ESD.site_states[f], 'aa' ) 
                    rho2 = g.find_rho( ESD.site_states[g], ESD.site_states[g], 'aa' ) 
                    integral = ECI_integral( m=m, loc=(index,index), ECItype='ECI_K', pattern='<AO,AO|1/r|AO,AO>', f1=f, f2=g, rho1=rho1, rho2=rho2 ) 
                    ECI_integrals.append( integral )
                    rho1 = f.find_rho( ESD.site_states[f], ESD.site_states[f], 'bb' ) 
                    rho2 = g.find_rho( ESD.site_states[g], ESD.site_states[g], 'bb' ) 
                    integral = ECI_integral( m=m, loc=(index,index), ECItype='ECI_K', pattern='<AO,AO|1/r|AO,AO>', f1=f, f2=g, rho1=rho1, rho2=rho2 ) 
                    ECI_integrals.append( integral )
            #-----End of relationship[(0,0)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


            #-----Start of relationship[(0,1)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            for pair in relationship[(0,1)]:
                ESD1, ESD2 = pair['ESDs']
                i1, i2 = ESD1.index, ESD2.index
                f = pair['excitons']
                #V-integrals
                nucs = [ ( g.mol.atom_charge(i) - g.Q[i], g.mol.atom_coord(i) ) for g in sites for i in g.mol.natm 
                        if (f,g) in self.active_integrals['J'][(0,1)] ] 
                if len(nucs) > 0:
                    if f.densrep == 'AO':
                        rho = f.find_rho( ESD1.site_states[f], ESD2.site_states[f], 'tot' ) 
                        if rho != None:
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='ECI_V', pattern='<AO|1/(r-R)|AO>', f=f, nucs=nucs, rho=rho ) 
                            ECI_integrals.append( integral )
                # J-integrals
                for (g,h) in job.active_integrals['J'][(0,1)]:
                    if g is f or h is f:
                        if g.densrep == 'AO' and h.densrep == 'AO':
                            rho1 = g.find_rho( ESD1.site_states[g], ESD2.site_states[g], 'tot' ) 
                            rho2 = h.find_rho( ESD1.site_states[h], ESD2.site_states[h], 'tot' )
                            if rho1 != None and rho2 != None:
                                integral = ECI_integral( m=m, loc=(i1,i2), ECItype='ECI_J', pattern='<AO,AO|1/r|AO,AO>', f1=g, f2=h, rho1=rho1, rho2=rho2 ) 
                                ECI_integrals.append( integral )
                # K-integrals
                for (g,h) in job.active_integrals['K'][(0,1)]:
                    if g is f or h is f:
                        rho1 = g.find_rho( ESD1.site_states[g], ESD2.site_states[g], 'aa' ) 
                        rho2 = h.find_rho( ESD1.site_states[h], ESD2.site_states[h], 'aa' )
                        if rho1 != None and rho2 != None:
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='ECI_K', f1=g, f2=h, rho1=rho1, rho2=rho2 ) 
                            ECI_integrals.append( integral )
                        rho1 = g.find_rho( ESD1.site_states[g], ESD2.site_states[g], 'bb' ) 
                        rho2 = site.find_rho( ESD1.site_states[h], ESD2.site_states[h], 'bb' )
                        if rho1 != None and rho2 != None:
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='ECI_K', f1=g, f2=h, rho1=rho1, rho2=rho2 ) 
                            ECI_integrals.append( integral )
                        rho1 = site.find_rho( ESD1.site_states[g], ESD2.site_states[g], 'ab' ) 
                        rho2 = site.find_rho( ESD1.site_states[h], ESD2.site_states[h], 'ba' )
                        if rho1 != None and rho2 != None:
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='ECI_K', f1=g, f2=h, rho1=rho1, rho2=rho2 ) 
                            ECI_integrals.append( integral )
                        rho1 = site.find_rho( ESD1.site_states[g], ESD2.site_states[g], 'ba' ) 
                        rho2 = site.find_rho( ESD1.site_states[h], ESD2.site_states[h], 'ab' )
                        if rho1 != None and rho2 != None:
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='ECI_K', f1=g, f2=h, rho1=rho1, rho2=rho2 ) 
                            ECI_integrals.append( integral )
            #-----End of relationship[(0,1)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

            #-----Start of relationship[(0,2)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            for pair in relationship[(0,2)]:
                ESD1, ESD2 = pair['ESDs']
                i1, i2 = ESD1.index, ESD2.index
                f, g = pair['excitons']
                # J-integrals
                if (f,g) in job.active_integrals['J'][(0,2)]:
                    if f.densrep == 'AO' and g.densrep == 'AO':
                        rho1 = f.rho[(ESD1.site_states[f], ESD2.site_states[f], 'tot')]
                        rho2 = f.rho[(ESD1.site_states[g], ESD2.site_states[g], 'tot')]
                        if rho1 != None and rho2 != None:
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='ECI_J', pattern='<AO,AO|1/r|AO,AO>', f1=f, f2=g, rho1=rho1, rho2=rho2 ) 
                            ECI_integrals.append( integral )
                # K-integrals
                if (f,g) in job.active_integrals['K'][(0,2)]:
                    if g is f or h is f:
                        rho1 = f.rho[(ESD1.site_states[f], ESD2.site_states[f], 'aa')]
                        rho2 = f.rho[(ESD1.site_states[g], ESD2.site_states[g], 'aa')]
                        if rho1 != None and rho2 != None:
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='ECI_K', f1=f, f2=g, rho1=rho1, rho2=rho2 ) 
                            ECI_integrals.append( integral )
                        rho1 = f.rho[(ESD1.site_states[f], ESD2.site_states[f], 'bb')]
                        rho2 = f.rho[(ESD1.site_states[g], ESD2.site_states[g], 'bb')]
                        if rho1 != None and rho2 != None:
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='ECI_K', f1=f, f2=g, rho1=rho1, rho2=rho2 ) 
                            ECI_integrals.append( integral )
                        rho1 = f.rho[(ESD1.site_states[f], ESD2.site_states[f], 'ab')]
                        rho2 = f.rho[(ESD1.site_states[g], ESD2.site_states[g], 'ba')]
                        if rho1 != None and rho2 != None:
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='ECI_K', f1=f, f2=g, rho1=rho1, rho2=rho2 ) 
                            ECI_integrals.append( integral )
                        rho1 = f.rho[(ESD1.site_states[f], ESD2.site_states[f], 'ba')]
                        rho2 = f.rho[(ESD1.site_states[g], ESD2.site_states[g], 'ab')]
                        if rho1 != None and rho2 != None:
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='ECI_K', f1=f, f2=g, rho1=rho1, rho2=rho2 ) 
                            ECI_integrals.append( integral )
            #-----End of relationship[(0,2)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

            #-----Start of relationship[(1,0)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            for pair in relationship[(1,0)]:
                ESD1, ESD2 = pair['ESDs']
                i1, i2 = ESD1.index, ESD2.index
                d, a = pair['donors'], pair['acceptors']
                f1, f2 = sites[min(d.index,a.index)], sites[max(d.index,a.index)] 
                if d is f1: 
                    fewer1 = ESD2.site_states[d]
                    bigger1 = ESD1.site_states[d]
                    fewer2 = ESD1.site_states[a]
                    bigger2 = ESD2.site_states[a]
                else:
                    fewer1 = ESD1.site_states[a]
                    bigger1 = ESD2.site_states[a]
                    fewer2 = ESD2.site_states[d]
                    bigger2 = ESD1.site_states[d]

                if (f1,f2) in self.active_integrals['J'][(1,0)]:
                    spectators = [ h for h in sites
                                  if ( sites[min(d.index,h.index)], sites[max(d.index,h.index)] ) in self.active_integrals['J'][(1,0)] and
                                     ( sites[min(a.index,h.index)], sites[max(a.index,h.index)] ) in self.active_integrals['J'][(1,0)]
                                  ]
                    nucs += [ ( h.mol.atom_charge(i) -h.Q[i], h.mol.atom_coord(i) )  h in sites for i in h.mol.natm 
                             if h is f1 or h is f2 or h in spectators 
                             ] 
                    prefactor = ESD1.site_states[d].subnorm*ESD2.site_states[a].subnorm*(-1.)**ESD2.site_states[a].nel 

                    dyson1 = f1.find_dyson( bigger1, fewer1, 'a' )
                    dyson2 = f2.find_dyson( bigger2, fewer2, 'a' )
                    if dyson1 != None and dyson2 != None:
                        # basic V-integral
                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_V', f1=f1, f2=f2, phi1=dyson1, phi2=dyson2, nucs=nucs, prefactor=prefactor ) 
                        for site in sites:
                            # basic J-integrals
                            det = ESD1
                            if site is d: det = ESD2  # For donor, the "fewer" density is in ket 
                            rho = site.find_rho( det.site_states[site], det.site_states[site], 'tot' )
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='J', f1=f1, f2=f2, f3=site, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                            ECI_integrals.append( integral )

                            # basic K-integrals
                            det = ESD1
                            if site is d: det = ESD2
                            rho = site.find_rho( det.site_states[site], det.site_states[site], 'aa' )
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=site, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                            ECI_integrals.append( integral )


                    dyson1 = f1.find_dyson( bigger1, fewer1, 'b' )
                    dyson2 = f2.find_dyson( bigger2, fewer2, 'b' )
                    if dyson1 != None and dyson2 != None:
                        # basic V-integral
                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_V', f1=f1, f2=f2, phi1=dyson1, phi2=dyson2, nucs=nucs, prefactor=prefactor ) 
                        for site in sites:
                            # basic J-integrals
                            det = ESD1
                            if site is d: det = ESD2  # For donor, the "fewer" density is in ket 
                            rho = site.find_rho( det.site_states[site], det.site_states[site], 'tot' )
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='J', f1=f1, f2=f2, f3=site, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                            ECI_integrals.append( integral )

                            # basic K-integrals
                            det = ESD1
                            if site is d: det = ESD2
                            rho = site.find_rho( det.site_states[site], det.site_states[site], 'bb' )
                            integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=site, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                            ECI_integrals.append( integral )


                    # Sum over all other fewer states
                    # Sum over fewer states of f2
                    dyson1 = f1.find_dyson( bigger1, fewer1, 'a' )
                    if dyson1 != None:
                        for st2 in f2.states[fewer2.Z]:
                            if not st2 is fewer2:
                                dyson2 = f2.find_dyson( bigger2, st2, 'a' )
                                if dyson2 != None:
                                    # J
                                    if f2 is d: rho = f2.find_rho( st2, fewer2, 'tot' )
                                    if f2 is a: rho = f2.find_rho( fewer2, st2, 'tot' )
                                    if rho != None:
                                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='J', f1=f1, f2=f2, f3=f2, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                        ECI_integrals.append( integral )
                                    # K
                                    if f2 is d: rho = f2.find_rho( st2, fewer2, 'aa' )
                                    if f2 is a: rho = f2.find_rho( fewer2, st2, 'aa' )
                                    if rho != None:
                                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=f2, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                        ECI_integrals.append( integral )
                                dyson2 = f2.find_dyson( bigger2, st2, 'b' )
                                if dyson2 != None:
                                    # K
                                    if f2 is d: rho = f2.find_rho( st2, fewer2, 'ba' )
                                    if f2 is a: rho = f2.find_rho( fewer2, st2, 'ba' )
                                    if rho != None:
                                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=f2, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                        ECI_integrals.append( integral )
                    dyson1 = f1.find_dyson( bigger1, fewer1, 'b' )
                    if dyson1 != None:
                        for st2 in f2.states[fewer2.Z]:
                            if not st2 is fewer2:
                                dyson2 = f2.find_dyson( bigger2, st2, 'a' )
                                if dyson2 != None:
                                    # K
                                    if f2 is d: rho = f2.find_rho( st2, fewer2, 'ab' )
                                    if f2 is a: rho = f2.find_rho( fewer2, st2, 'ab' )
                                    if rho != None:
                                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=f2, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                        ECI_integrals.append( integral )
                                dyson2 = f2.find_dyson( bigger2, st2, 'b' )
                                if dyson2 != None:
                                    # J
                                    if f2 is d: rho = f2.find_rho( st2, fewer2, 'tot' )
                                    if f2 is a: rho = f2.find_rho( fewer2, st2, 'tot' )
                                    if rho != None:
                                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='J', f1=f1, f2=f2, f3=f2, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                        ECI_integrals.append( integral )
                                    # K
                                    if f2 is d: rho = f2.find_rho( st2, fewer2, 'bb' )
                                    if f2 is a: rho = f2.find_rho( fewer2, st2, 'bb' )
                                    if rho != None:
                                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=f2, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                        ECI_integrals.append( integral )
                    # Sum over fewer states of f1
                    dyson2 = f2.find_dyson( bigger2, fewer2, 'a' )
                    if dyson2 != None:
                        for st1 in f1.states[fewer1.Z]:
                            if not st1 is fewer1:
                                dyson1 = f1.find_dyson( bigger1, st1, 'a' )
                                if dyson1 != None:
                                    # J
                                    if f1 is d: rho = f1.find_rho( st1, fewer1, 'tot' )
                                    if f1 is a: rho = f1.find_rho( fewer1, st1, 'tot' )
                                    if rho != None:
                                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='J', f1=f1, f2=f2, f3=f1, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                        ECI_integrals.append( integral )
                                    # K
                                    if f1 is d: rho = f1.find_rho( st1, fewer1, 'aa' )
                                    if f1 is a: rho = f1.find_rho( fewer1, st1, 'aa' )
                                    if rho != None:
                                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=f1, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                        ECI_integrals.append( integral )
                                dyson1 = f1.find_dyson( bigger1, st1, 'b' )
                                if dyson1 != None:
                                    # K
                                    if f1 is d: rho = f1.find_rho( st1, fewer1, 'ba' )
                                    if f1 is a: rho = f1.find_rho( fewer1, st1, 'ba' )
                                    if rho != None:
                                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=f1, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                        ECI_integrals.append( integral )
                    dyson2 = f2.find_dyson( bigger2, fewer2, 'b' )
                    if dyson2 != None:
                        for st1 in f1.states[fewer1.Z]:
                            if not st1 is fewer1:
                                dyson1 = f1.find_dyson( bigger1, st1, 'a' )
                                if dyson1 != None:
                                    # K
                                    if f1 is d: rho = f1.find_rho( st1, fewer1, 'ab' )
                                    if f1 is a: rho = f1.find_rho( fewer1, st1, 'ab' )
                                    if rho != None:
                                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=f1, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                        ECI_integrals.append( integral )
                                dyson1 = f1.find_dyson( bigger1, st1, 'b' )
                                if dyson1 != None:
                                    # J
                                    if f1 is d: rho = f1.find_rho( st1, fewer1, 'tot' )
                                    if f1 is a: rho = f1.find_rho( fewer1, st1, 'tot' )
                                    if rho != None:
                                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='J', f1=f1, f2=f2, f3=f1, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                        ECI_integrals.append( integral )
                                    # K
                                    if f1 is d: rho = f1.find_rho( st1, fewer1, 'bb' )
                                    if f1 is a: rho = f1.find_rho( fewer1, st1, 'bb' )
                                    if rho != None:
                                        integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=f1, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                        ECI_integrals.append( integral )
            #-----End of relationship[(1,0)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

            #-----Start of relationship[(1,1)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            for pair in relationship[(1,1)]:
                ESD1, ESD2 = pair['ESDs']
                i1, i2 = ESD1.index, ESD2.index
                d, a, e = pair['donors'], pair['acceptors'], pair['excitons']
                f1, f2 = sites[min(d.index,a.index)], sites[max(d.index,a.index)] 
                if d is f1: 
                    fewer1 = ESD2.site_states[d]
                    bigger1 = ESD1.site_states[d]
                    fewer2 = ESD1.site_states[a]
                    bigger2 = ESD2.site_states[a]
                else:
                    fewer1 = ESD1.site_states[a]
                    bigger1 = ESD2.site_states[a]
                    fewer2 = ESD2.site_states[d]
                    bigger2 = ESD1.site_states[d]

                if (f1,f2) in self.active_integrals['J'][(1,1)] and 
                (sites[min(f1.index,e.index)], sites[max(f1.index,e.index)]) in self.active_integrals['J'][(1,1)] and
                (sites[min(f2.index,e.index)], sites[max(f2.index,e.index)]) in self.active_integrals['J'][(1,1)]:
                    dyson1 = f1.find_dyson( bigger1, fewer1, 'a' )
                    if dyson1 != None:
                        dyson2 = f2.find_dyson( bigger2, fewer2, 'a' )
                        if dyson2 != None:
                            rho = e.find_rho( ESD1.site_states[e], ESD2.site_states[e], 'tot' )
                            if rho != None:
                                # J-integral
                                integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='J', f1=f1, f2=f2, f3=e, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                ECI_integrals.append( integral )
                            rho = e.find_rho( ESD1.site_states[e], ESD2.site_states[e], 'aa' )
                            if rho != None:
                                # K-integral
                                integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=e, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                ECI_integrals.append( integral )
                        dyson2 = f2.find_dyson( bigger2, fewer2, 'b' )
                        if dyson2 != None:
                            rho = e.find_rho( ESD1.site_states[e], ESD2.site_states[e], 'ba' )
                            if rho != None:
                                # K-integral
                                integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=e, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                ECI_integrals.append( integral )
                    dyson1 = f1.find_dyson( bigger1, fewer1, 'b' )
                    if dyson1 != None:
                        dyson2 = f2.find_dyson( bigger2, fewer2, 'a' )
                        if dyson2 != None:
                            rho = e.find_rho( ESD1.site_states[e], ESD2.site_states[e], 'ab' )
                            if rho != None:
                                # K-integral
                                integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=e, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                ECI_integrals.append( integral )
                        dyson2 = f2.find_dyson( bigger2, fewer2, 'b' )
                        if dyson2 != None:
                            rho = e.find_rho( ESD1.site_states[e], ESD2.site_states[e], 'tot' )
                            if rho != None:
                                # J-integral
                                integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='J', f1=f1, f2=f2, f3=e, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                ECI_integrals.append( integral )
                            rho = e.find_rho( ESD1.site_states[e], ESD2.site_states[e], 'bb' )
                            if rho != None:
                                # K-integral
                                integral = ECI_integral( m=m, loc=(i1,i2), ECItype='SCT_JK', which='K', f1=f1, f2=f2, f3=e, phi1=dyson1, phi2=dyson2, rho=rho, prefactor=prefactor ) 
                                ECI_integrals.append( integral )
            #-----End of relationship[(1,1)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

        return ECI_integrals









        
#----END ECI------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

