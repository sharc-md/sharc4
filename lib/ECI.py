#!/usr/bin/env python3
import os
import sys
import time
import itertools
import math
import numpy as np
import scipy as sp
import sympy
from multiprocessing import Pool, Manager, Process
import multiprocessing

from logger import logging, CustomFormatter
from pyscf import gto
from pyscf import df as density_fitting
from pyscf import lib as pyscflib

merge_moles = gto.mole.conc_mol

#----START of calculation class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
class calculation:
    def __init__( self, **kwargs ):
        for key, value in kwargs.items():
            setattr(self,key,value)
#----END of calculation class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


#----START of fragment class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
class fragment:
    def __init__( self, **kwargs ):
        for key, value in kwargs.items():
            setattr(self,key,value)
        return

    def __hash__(self):
        return self.label.__hash__()

    def __eq__(self,other):
        return self.label == other.label

    def __repr__(self):
        return self.label

    def find_rho(self,s1,s2,spin):
        if s1.Z != s2.Z: return None
        return self.rho[s1.Z].get( (s1,s2,spin), None)

            

#----END of fragment class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


#----START of excitonic_slater_determinant class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
class excitonic_slater_determinant:
    def __init__(self, sites, site_states):
        if isinstance( site_states, list ):
            self.site_states = {} # list of electronic_state instances
            for state, site in zip( site_states, sites ):
                self.site_states[site] = state
        elif isinstance( site_states, dict ):
            self.site_states = site_states.copy()
        self.Z = sum( [ self.site_states[site].Z for site in sites ] )
        self.M = sum( [ self.site_states[site].M for site in sites ] )
        self.index = None

    def __repr__(self):
        s = '[ '
        for site, state in self.site_states.items():
            if state.Z == 0: 
                Z = '^(0)'
            elif state.Z > 0: 
                Z = '^('+str(state.Z)+'+)'
            else:
                Z = '^('+str(abs(state.Z))+'-)'
            s += site.label+Z+' : '+state.symbol(Z=False)+' | '
        s = s[0:len(s)-3] + ' ]'
        return s

    def __hash__(self):
        return repr(self).__hash__()
        #  return ' '.join([s.__hash__() for s in self.site_states.values() ]).__hash__()

    def __eq__(self,other):
        return all([ s1 is s2 for s1, s2 in zip(self.site_states.values(), other.site_states.values())])

    def __floordiv__(self,other):
        return all([ s1 // s2 for s1, s2 in zip(self.site_states.values(), other.site_states.values())])

    #----START of excitonic_slater_determinant.compare------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def compare(self,other):
        sites = list(self.site_states.keys())
        diffs = [ site for site in sites if not self.site_states[site] is other.site_states[site] ]
        ndiffs = len(diffs)
        if ndiffs == 0:
            comparison = { 'relationship' : (0,0) }
        elif ndiffs == 1:
            comparison = { 'relationship' : (0, 1), 'exciton' : diffs[0] }
        elif ndiffs == 2:
            f, g = diffs
            sf1, sg1 = self.site_states[f], self.site_states[g]
            sf2, sg2 = other.site_states[f], other.site_states[g]
            dZf = sf2.Z - sf1.Z
            dZg = sg2.Z - sg1.Z
            if dZf == 0 and dZg == 0:
                comparison = { 'relationship' : (0,2), 'excitons' : diffs }
            elif dZf == 1 and dZg == -1:
                comparison = { 'relationship' : (1,0), 'donor' : f, 'acceptor' : g }
            elif dZf == -1 and dZg == 1:
                comparison = { 'relationship' : (1,0), 'donor' : g, 'acceptor' : f }
            elif dZf == -2 and dZg == 2:
                pass # this requires double-DO, would go to relationship (2,0)
            elif dZf == 2 and dZg == -2:
                pass # this requires double-DO, would go to relationship (2,0) 
            else: return None
        elif ndiffs == 3:
            f, g, h = diffs
            sf1, sg1, sh1 = self.site_states[f], self.site_states[g], self.site_states[h] 
            sf2, sg2, sh2 = other.site_states[f], other.site_states[g], other.site_states[h]
            dZf = sf2.Z - sf1.Z
            dZg = sg2.Z - sg1.Z
            dZg = sh2.Z - sh1.Z
            if dZf == 1 and dZg == -1 and dZh == 0:
                comparison = { 'relationship' : (1,1), 'donor' : f, 'acceptor' : g, 'exciton' : h }
            elif dZf == -1 and dZg == 1 and dZh == 0:
                comparison = { 'relationship' : (1,1), 'donor' : g, 'acceptor' : g, 'exciton' : h }
            elif dZf == 1 and dZg == 0 and dZh == -1:
                comparison = { 'relationship' : (1,1), 'donor' : f, 'acceptor' : h, 'exciton' : g }
            elif dZf == -1 and dZg == 0 and dZh == 1:
                comparison = { 'relationship' : (1,1), 'donor' : h, 'acceptor' : f, 'exciton' : g }
            elif dZf == 0 and dZg == 1 and dZh == -1:
                comparison = { 'relationship' : (1,1), 'donor' : g, 'acceptor' : h, 'exciton' : f }
            elif dZf == 0 and dZg == -1 and dZh == 1:
                comparison = { 'relationship' : (1,1), 'donor' : h, 'acceptor' : g, 'exciton' : f }
            elif dZf == 2 and dZg == -1 and dZh == -1:
                pass # This is (2,0) but with one double-donor and two single-acceptors, e.g. < S0^{0}, S1^{0} S0^{0} | H | S0^{2+} D0^{1-} D3^{1-} > = J - K between double-DO on fragment 1 and a product of DOs on fragments 2 and 3.
            elif dZf == -2 and dZg == 1 and dZh == 1:
                pass # Similar to upper 
            elif dZf == -1 and dZg == 2 and dZh == -1:
                pass # Similar to upper 
            elif dZf == 1 and dZg == -2 and dZh == 1:
                pass # Similar to upper 
            elif dZf == -1 and dZg == -1 and dZh == 2:
                pass # Similar to upper 
            elif dZf == 1 and dZg == 1 and dZh == -2:
                pass # Similar to upper 
            else: return None
        #elif ndiffs == 4:
        #    f, g, h, m = diffs
        #    sf1, sg1, sh1, sm1 = self.site_states[f], self.site_states[g], self.site_states[h], self.site_states[m] 
        #    sf2, sg2, sh2, sm2 = ESD2.site_states[f], ESD2.site_states[g], ESD2.site_states[h], ESD2.site_states[m]
        #    dZf = sf2.Z - sf1.Z
        #    dZg = sg2.Z - sg1.Z
        #    dZh = sh2.Z - sh1.Z
        #    dZm = sm2.Z - sm1.Z
        #    dZall = np.array( [ dZf, dZg, dZh, dZm ], dtype=int )
        #    donors = np.nonzero( dZall == 1 )[0]
        #    accpetors = np.nonzero( dZall == -1 )[0]
        #    if len(donors) == 2 and len(acceptors) == 2: # Double charge transfer with two donors and two acceptors
        #        relationships[(2,0)].append( { 'donors': diffs[donors], 'acceptors' : diffs[acceptors], 'ESDs': (ESD1,ESD2) } )
        else:
            return None
        return comparison
    #----END of excitonic_slater_determinant.compare------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
#----END of excitonic_slater_determinant class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


#----START of excitonic_configuration_state_function class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
class excitonic_configuration_state_function:
    def __init__( self, m, ESDs, U ):
        self.index = None
        self.multiplicity = m
        self.ESDs = ESDs
        self.U = U
        ESD = self.ESDs[0]
        sites = list(ESD.site_states.keys())
        self.site_states = ESD.site_states 
        self.ct_rank = sum( [ abs(self.site_states[site].Z-site.Z) for site in sites ] )/2
        self.eci_rank = sum( [ 1 for site, state in self.site_states.items() if not any( [ state is astate for astate in site.aufbau_states ] ) ] )

    def __repr__(self):
        s = '( '
        for site, state in self.site_states.items():
            if not state in site.aufbau_states or state.Z != site.Z:
                if state.Z == 0: 
                    Z = '^(0)'
                elif state.Z > 0: 
                    Z = '^('+str(state.Z)+'+)'
                else:
                    Z = '^('+str(abs(state.Z))+'-)'
                s += site.label+Z+' : '+state.symbol(Z=False, M=False)+' | '
        if s == '( ':
            s = '( 0 )'
        if s != '( 0 )': s = s[0:len(s)-3] + ' )'
        return s

    def __hash__(self):
        return self.__repr__().hash()
#----END of excitonic_configuration_state_function class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   


#----START of excitonic_basis class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
class excitonic_basis:
    def __init__( self, ESDs, ECSFs, U ):
        self.ESDs = ESDs
        self.ECSFs = ECSFs
        self.U = U
        for i, ESD in enumerate( self.ESDs ):
            ESD.index = i
        for i, ECSF in enumerate( self.ECSFs ):
            ECSF.index = i
        self.determine_relationships()

    #----START of excitonic_basis.determine_relationships------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def determine_relationships(self):
        ESDs = self.ESDs
        self.relationships = {(0,0):[], (0,1):[], (0,2):[], (1,0):[], (1,1):[], (2,0):[]} 
        for i1, ESD1 in enumerate( ESDs ):
            for i2, ESD2 in enumerate( ESDs[i1:] ):
                comparison = ESD1.compare(ESD2)
                if comparison != None:
                    rel =  comparison['relationship']
                    del comparison['relationship']
                    comparison['ESDs'] = ( ESD1, ESD2 )
                    comparison['indices'] = (i1,i2+i1)
                    self.relationships[rel].append( comparison )
        return 
    #----END of excitonic_basis.determine_relationships------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
#----END of excitonic_basis class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

#----START of ECI_integral class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
class ECI_integral():
    def __init__( self, **kwargs ):
        for key, value in kwargs.items():
            setattr(self,key,value)
        #  self.index = index
        return

    def __hash__(self):
        s = ''
        for atribute, value in vars(self):
            if atribute in ['ECItype', 'pattern', 'nucs', 'f', 'f1', 'f2', 'f3']:
                s += repr(value)+' '  
        return s.__hash__()
#----END of ECI_integral class------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

#----START of ECI class--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
class ECI:
    #  def __init__(self, job, sites, outputlogname="ECI", logfile="ECI.log", loglevel=log.root.level):
    def __init__(self, job, sites, output):
        # Input
        self.job = job 
        self.sites = sites

        d = {m:None for m in self.job.multiplicities}

        # Intermediate
        self.ECIbasis = d.copy()
        self.H = d.copy()
        self.J = d.copy() 
        self.K = d.copy()
        self.S = d.copy()
        self.h2 = d.copy()
        self.P = {}

        # Output
        self.E = d.copy() 
        self.Psi = {'ECSF':d.copy(),'ESD':d.copy()}
        self.dignostics = d.copy()
        self.PR = d.copy() 
        self.mu = d.copy()
        self.soc = d.copy()
        self.grad = d.copy() 
        self.nacs = d.copy()

        # Logger
        self.log = logging.getLogger(output+'.log')
        self.log.propagate = False
        self.log.handlers = []
        self.log.setLevel('INFO')
        hdlr = (
            logging.FileHandler(filename=output+'.log', mode="w", encoding="utf-8")
        )
        hdlr._name = output+"Handler"
        hdlr.setFormatter(CustomFormatter())
        self.log.addHandler(hdlr)
        self.log.print = self.log.info
        return

    #----START of ECI.run------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def run(self):
        self.log.print('============================================================================================================================================================')
        self.log.print('                                                        START OF ECI calculation')
        self.log.print('============================================================================================================================================================')
        self.log.print('')
        self.configure()                                # Sets number of CPUs, transforms ECI_level and CT_level so that fragment instances are in sets/lists, etc.
        t1 = time.time()
        self.construct_excitonic_basis()                # Building ECI-CT basis
        t2 = time.time()
        self.log.print(' Time elapsed in constructing the ECI-CT basis (sec) = '+str(round(t2-t1,3)))
        self.allocate()
        #  t1 = time.time()
        #  self.calculate_Smat()
        #  t2 = time.time()
        #  self.log.print(' Time elapsed in calculating S-mat (sec) = '+str(round(t2-t1,3)))
        t1 = time.time()
        self.calculate_Hmat()                           # Construct entire ECI-CT Hamiltonian for all multiplicities
        t2 = time.time()
        self.log.print(' Time elapsed in calculating H-mat, including h2-mat (sec) = '+str(round(t2-t1,3)))
        self.calculate_eigenstates()                     # Diagonalize Hamiltonian matrix for each multiplicity
        self.calculate_properties()                     # Calculate all properties requested by master
        self.print_states()
        self.log.print('============================================================================================================================================================')
        self.log.print('                                                        END of ECI calculation')
        self.log.print('============================================================================================================================================================')
        self.log.print('')
        return
    #----END of ECI.run------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

    #----START of ECI.configure------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def configure(self):
        sites = self.sites
        job = self.job

        # Sets num of CPUs for all libraries used by numpy
        for variable in ["OMP_NUM_THREADS", "OPENBLAS_NUM_THREADS", "BLAS_NUM_THREADS", "MKL_NUM_THREADS", "VECLIB_MAXIMUM_THREADS", "NUMEXPR_NUM_THREADS"]: 
            os.environ[variable] = str(job.ncpu)


        # Transforms the entries in eci_level and ...
        eci_level = {}
        for rank, value in job.eci_level.items():
            if rank == 0:
                eci_level[0] = value
            else:
                eci_level[rank] = []
                for subset in value:
                    newsubset = [ site for site in sites if site.label in subset ]
                    eci_level[rank].append(newsubset)
        job.eci_level = eci_level

        # ... in ct_level 
        ct_level = {}
        for rank, value in job.ct_level.items():
            if rank == 0:
                ct_level[0] = value
            else:
                ct_level[rank] = []
                for (donor_labels, acceptor_labels) in value:
                    donors, acceptors = [], []
                    for label in donor_labels:
                        for site in sites:
                            if site.label == label:
                                donors.append(site)
                                break
                    for label in acceptor_labels:
                        for site in sites:
                            if site.label == label:
                                acceptors.append(site)
                                break
                    ct_level[rank].append( (tuple(donors), tuple(acceptors)) )
        job.ct_level = ct_level

        # Transform active_integrals
        for JK in ["J","K"]:
            for int_type in [(0,0),(0,1),(0,2),(1,0),(1,1)]:
                newlist = []
                for multiple in job.active_integrals[JK][int_type]:
                    newtuple = []
                    for label in multiple:
                        newtuple.append([ site for site in sites if site.label == label ][0])
                    newtuple = tuple(newtuple)
                    newlist.append(newtuple)
                job.active_integrals[JK][int_type] = newlist

        self.log.print('-----------------------------BASIC INFOS OF THE CALCULATION---------------------------')
        self.log.print(' The number of CPUs for NUMPY and PYSCF set up to '+str(job.ncpu))
        self.log.print(' ECI level:')
        eci_dict = {0: 'GS', 1: 'LE', 2: 'DLE', 3: 'TLE', 4: 'QLE'}
        for i in range(5, len(sites)+1):
            eci_dict[i] = str(i)+'LE'
        for level, value in job.eci_level.items():
            self.log.print(f"{eci_dict[level]:>5}"+': '+str(value))
        self.log.print('--------------------------------------------------------------------------------------')

        self.log.print('')
        self.log.print('-----------------------------BASIC INFOS OF THE SITES---------------------------------')
        for f in sites:
            self.log.print('')
            self.log.print(' Site: '+f.label)
            self.log.print('    Embedding charges: ')
            self.log.print('       '+' '.join([f"{f.mol.atom_pure_symbol(i):>8}" for i in range(f.mol.natm) ]))
            self.log.print('          '+' '.join([f"{f.Q[i]: 8.5f}" for i in range(f.mol.natm) ]))
            S = f.mol.intor('int1e_ovlp')
            self.log.print('    Number of electrons calculated from the densities:')
            for Z, densities in f.rho.items():
                self.log.print('       Charge: '+str(Z))
                for (s1,s2,spin), rho in densities.items():
                    N = np.einsum("ij,ij->", S, rho)
                    self.log.print('            '+s1.symbol(Z=False) + " ---" + spin + "---> " + s2.symbol(Z=False) + " :" f"{N: 12.8f}", extra={"simple": True})
            if len(f.phi) > 0:
                self.log.print('    Dyson squared norms:')
                for (Z1,Z2), DOs in f.phi.items():
                    self.log.print('       Charges: '+str(Z1)+' '+str(Z2))
                    for (s1,s2,spin), phi in DOs.items():
                        N = np.einsum("i,ij,j->", phi, S, phi)
                        self.log.print('            '+s1.symbol(Z=False) + " ---" + spin + "---> " + s2.symbol(Z=False) + " :" f"{N: 12.8f}", extra={"simple": True})
                self.log.print('    Subnorms of the "neutral" states:')
                for Z1, states1 in f.states.items():
                    for s1 in states1:
                        N = 0.
                        for Z2, states2 in f.states.items():
                            if Z1 == Z2 - 1:
                                for s2 in states2:
                                    for spin in ['a', 'b']:
                                        if (s1,s2,spin) in f.phi[(Z1,Z2)]:
                                            phi = f.phi[(Z1,Z2)][(s1,s2,spin)]
                                            N += np.einsum("i,ij,j->", phi, S, phi)
                                for s21 in states2:
                                    for s22 in states2:
                                        for sigma in ['a', 'b']:
                                            for tau in ['a', 'b']:
                                                if (s1,s21,sigma) in f.phi[(Z1,Z2)] and (s1,s22,tau) in f.phi[(Z1,Z2)] and (s22,s21,sigma+tau) in f.rho[Z2]:
                                                    phi1 = f.phi[(Z1,Z2)][(s1,s21,sigma)]
                                                    phi2 = f.phi[(Z1,Z2)][(s1,s22,tau)]
                                                    rho = f.rho[Z2][(s22,s21,sigma+tau)]
                                                    N -= np.einsum("i,ij,jk,kl,l->", phi1, S, rho, S, phi2, optimize=True )
                        self.log.print('      State: '+s1.symbol()+', Squared subnorm = '+str(N), extra={"simple": True})
                        s1.C['subnorm'] = math.sqrt(N)
        self.log.print('--------------------------------------------------------------------------------------')

        return
    #----END of ECI.configure------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

    #----START of ECI.construct_excitonic_basis------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def construct_excitonic_basis(self):
        self.log.print('')
        self.log.print('--------------------------CONSTRUCTION OF THE ECI BASIS-------------------------------')
        allESDs = self.get_aufbaus()
        allESDs = self.make_excitations( allESDs )
        allESDs = self.overlap_criterion( allESDs )
        for m in self.job.multiplicities:
            ESDs, ECSFs, U = self.spin_adapt( m, allESDs )
            self.ECIbasis[m] = excitonic_basis( ESDs, ECSFs, U )
        self.log.print('--------------------------------------------------------------------------------------')
        return
    #----END of ECI.construct_excitonic_basis------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    
    #----START of ECI.get_aufbaus------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def get_aufbaus(self):
        job = self.job
        sites = self.sites

        nf = len(sites)
        aufbaus = []
        aufbaustates = [ site.aufbau_states for site in sites ]
        aufbaus = list(itertools.product(*aufbaustates)) 
        ESDs = [ excitonic_slater_determinant(sites=sites, site_states=list(aufbau)) for aufbau in aufbaus ]
    
        # Take only those with correct charge
        ESDs = [ ESD for ESD in ESDs if ESD.Z == job.charge ]
        if len( ESDs ) == 0:
            raise ValueError(' No aufbau ESD has the requested charge '+str(job.charge)+'!')
    
        # Take only those with requested CT level
        status = []
        #  self.log.print('job.ct_level = '+str(job.ct_level))
        for aufbau in ESDs:
            #  self.log.print(repr(aufbau))
            status.append(False)
            deltaZ = [ aufbau.site_states[f].Z - f.Z for f in sites ]
            donors = tuple([ f for dZ, f in zip( deltaZ, sites ) for i in range(dZ) if dZ > 0 ])
            acceptors = tuple([ f for dZ, f in zip( deltaZ, sites ) for i in range(-dZ) if dZ < 0 ]) 
            #  self.log.print(' Donors = '+' '.join([f.label for f in donors ] ))
            #  self.log.print(' Acceptors = '+' '.join([f.label for f in acceptors ]))
            level = sum([ abs(dZ) for dZ in deltaZ ])//2
            #  print('From ECI class: level = ', level)
            #  print('From ECI class: donors = ', repr(donors))
            #  print('From ECI class: acceptors = ', repr(acceptors))
            #  print('From ECI class: job.ct_level = ', job.ct_level.get(level,[]))
            if (donors, acceptors) in job.ct_level.get(level, []):
                #  print('From ECI class: Tu sam ')
                status[-1] = True
        #  print('From ECI class: states = ', status)
        ESDs = [ ESD for i, ESD in enumerate(ESDs) if status[i] ]
    
        self.log.print(' Number of aufbau ESDs with correct charge and CT-level = '+str(len(ESDs)))
        for ESD in ESDs:
            self.log.print('     '+repr(ESD))
        return ESDs
    #----END of ECI.get_aufbaus------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

    #----START of ECI.make_excitations------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def make_excitations( self, ESDs ):
        job = self.job
        sites = self.sites
        excitedESDs = []
        for aufbau in ESDs:
            for level, subsets in job.eci_level.items():
                if level > 0:
                    for subset in subsets:
                        site_state_lists = [ [ s for s in f.states[aufbau.site_states[f].Z] if not s in f.aufbau_states ] for f in subset ]
                        excitations = list(itertools.product(*site_state_lists))
                        for e in excitations:
                            site_states = [ aufbau.site_states[f] if not f in subset else e[subset.index(f)] for f in sites ]
                            ESD = excitonic_slater_determinant( sites=sites, site_states=site_states )
                            if not ESD in excitedESDs: excitedESDs.append(ESD) 
        if job.eci_level.get(0,False):
            ESDs = ESDs + excitedESDs
        else:
            ESDs = excitedESDs
        self.log.print(' Number of aufbau and excited ESDs with correct charge and CT-level = '+str(len(ESDs)))
        for ESD in ESDs:
            self.log.print('     '+repr(ESD))
        return ESDs                        
    #----END of ECI.make_excitations------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

    #----START of ECI.overlap_criterion------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def overlap_criterion( self, ESDs ):
        job = self.job
        sites = self.sites

        # Get site-state pairs that overlap too much
        pairs_to_expell = {}

        active_pairs = []
        for JK in ["J","K"]:
            for int_type in [(0,0),(0,1),(0,2)]:
                active_pairs += job.active_integrals[JK][int_type]
        active_pairs = list(set(active_pairs))

        for fpair in active_pairs:
            pairs_to_expell[fpair] = []
            f1, f2 = fpair
            dimer = merge_moles( f1.mol, f2.mol )
            SAO = dimer.intor('int1e_ovlp')[ 0:f1.mol.nao:, f1.mol.nao: ]
    
            # Overlaps of aufbau states (for each pair of charges)
            #  Sref = {}
            #  for s1 in f1.aufbau_states:
                #  for s2 in f2.aufbau_states:
                    #  if not (s1.Z,s2.Z,f1,f2) in Sref:
                        #  O = 0.
                        #  for spin in ['aa','bb']:
                            #  rho1 = f1.rho[s1.Z][(s1, s1, spin)]
                            #  rho2 = f2.rho[s2.Z][(s2, s2, spin)]
                            #  O += np.einsum( 'ij,kl,il,jk', rho1, rho2, SAO, SAO, optimize=['einsum_path', (0, 2), (0, 1), (0, 1)] ) 
                        #  Sref[(s1.Z,s2.Z,f1,f2)] = 1. - O
            

            # True state overlap
            #  S = {}
            #  Sref = {}
            for Z1, states1 in f1.states.items():
                for Z2, states2 in f2.states.items():
                    S = {}
                    for s1 in states1:
                        for s2 in states2:
                            O = 0.
                            for spin in ['aa','bb']:
                                rho1 = f1.rho[s1.Z][(s1, s1, spin)]
                                rho2 = f2.rho[s2.Z][(s2, s2, spin)]
                                O += np.einsum( 'ij,kl,il,jk', rho1, rho2, SAO, SAO, optimize=['einsum_path', (0, 2), (0, 1), (0, 1)] ) 
                            S[(s1,s2)] = abs(1. - O)
                            #  if S[(s1,s2)] > Omax:
                                #  Omax = S[(s1,s2)]
                                #  maxpair[(Z1,Z2)] = (s1,s2)
                    Omax = max(S.values())
                    for (s1,s2), O in S.items():
                        if O/Omax < job.tO:
                            pairs_to_expell[(f1,f2)].append( (s1,s2) )

            #  Omax = max(S.values())
            #  #  self.log.print('Omax for pair '+f1.label+','+f2.label+' = '+str(Omax))
            #  for (s1,s2), O in S.items():
                #  #  self.log.print(' States '+repr(s1)+'->'+repr(s2)+', O = '+str(O)+', relO = '+str(O/Omax) )
                #  if O/Omax < job.tO:
                    #  pairs_to_expell[(f1,f2)].append( (s1,s2) )
    
        # Remove ESDs containing at least one such site-state pair
        toremove = []
        for ESD in ESDs:
            for (f1,f2), spairs in pairs_to_expell.items():
                for (s1,s2) in spairs:
                    if ESD.site_states[f1] // s1 and ESD.site_states[f2] // s2:
                        self.log.print(' Expelling ESD '+repr(ESD)+' due to the overlap of '+repr(s1)+' of '+f1.label+' and '+repr(s2)+' of '+f2.label)
                        toremove.append( ESD )
                        break
        ESDs = [ ESD for ESD in ESDs if not ESD in toremove ]
        self.log.print(' Number of ESDs after overlap-criterion = '+str(len(ESDs)))
        return ESDs                    
    #----END of ECI.overlap_criterion------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
        
    #----START of ECI.spin_adapt------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def spin_adapt(self, m, allESDs):
        ESDs = [ ESD for ESD in allESDs if ESD.M == (m-1) ]
        self.log.print(' Constructed '+str(len(ESDs))+ ' ESDs with MS = '+str(ESDs[0].M/2))
        for ESD in ESDs:
            self.log.print('     '+repr(ESD))

        groups = {}
        for ESD in ESDs:
            found = False
            for keyESD in groups:
                if keyESD // ESD:
                    groups[keyESD].append( ESD )
                    found = True
            if not found:
                groups[ESD] = [ ESD ]

        ECSFs = []
        for keyESD, groupESDs in groups.items():
            S2mat = self.calculate_S2mat(groupESDs)
            S2val, groupU = np.linalg.eigh( S2mat, 'U' )
            mults = ( np.sqrt(4.*abs(S2val)) + 1. ).astype(int)
            for i, mult in enumerate(mults):
                if mult == m:
                    ECSFs.append( excitonic_configuration_state_function( m, groupESDs, groupU[:,i] ) )
        if len(ECSFs) == 0:
            raise ValueError(f"  No ECSF that can be generated from given states and chosen ECI expansion corresponds to the requested multiplicity {m} ( possible multiplicities =  {mults}).r")

        # Build big U
        U = np.zeros((len(ESDs),len(ECSFs)))
        for i, ESD in enumerate(ESDs):
            for j, ECSF in enumerate(ECSFs):
                if ESD in ECSF.ESDs:
                    U[i,j] = ECSF.U[ECSF.ESDs.index(ESD)]

        self.log.print(' Constructed '+str(len(ECSFs))+' ECSFs of multiplicity '+str(m)+', spanned by '+str(len(ESDs))+' ESDs')
        for i, ECSF in enumerate(ECSFs):
            self.log.print('')
            self.log.print('     '+repr(ECSF))
            for j, ESD in enumerate(ECSF.ESDs):
                self.log.print('         '+f"{ECSF.U[j]: 10.6f}"+repr(ESD))

        return ESDs, ECSFs, U
    #----END of ECI.spin_adapt------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

    #----START of ECI.calculate_S2mat------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def calculate_S2mat(self, ESDs):
        nESD = len( ESDs )
        S2mat = np.zeros( (nESD, nESD) )
        sites = list(ESDs[0].site_states.keys())

        # Diagonal
        for i, ESD in enumerate( ESDs ):
            S2mat[i,i] += sum( [ ESD.site_states[f].S/2. * ( ESD.site_states[f].S/2. + 1. ) for f in sites ] ) 
            S2mat[i,i] += 2.*sum( [ ESD.site_states[f].M/2.*ESD.site_states[g].M/2. for j,f in enumerate(sites) for g in sites[j+1:] ] )
        # Off-diagonal
        for (i,j) in itertools.combinations( range(len(ESDs)), 2 ):
            ESD1, ESD2 = ESDs[i], ESDs[j]
            diffs = [ f for f in ESD1.site_states if not ESD1.site_states[f] is ESD2.site_states[f] ]
            if len(diffs) == 2:
                f, g = diffs
                sf1, sg1 = ESD1.site_states[f], ESD1.site_states[g]
                sf2, sg2 = ESD2.site_states[f], ESD2.site_states[g]
                if sf1 // sf2 and sg1 // sg2: # Comparison up to MS value
                    if sf1.M == sf2.M - 2 and sg1.M == sg2.M + 2:
                        x = sf1.S/2.*( sf1.S/2. + 1. ) - sf1.M/2.*( sf1.M/2. + 1. ) 
                        y = sg1.S/2.*( sg1.S/2. + 1. ) - sg1.M/2.*( sg1.M/2. - 1. ) 
                        S2mat[i,j] = math.sqrt(x)*math.sqrt(y)
                    elif sf1.M == sf2.M + 2 and sg1.M == sg2.M - 2: 
                        x = sf1.S/2.*( sf1.S/2. + 1. ) - sf1.M/2.*( sf1.M/2. - 1. ) 
                        y = sg1.S/2.*( sg1.S/2. + 1. ) - sg1.M/2.*( sg1.M/2. + 1. ) 
                        S2mat[i,j] = math.sqrt(x)*math.sqrt(y)
        return S2mat
    #----END of ECI.calculate_S2mat------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

    #----START of ECI.allocate------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def allocate(self):
        job = self.job
        sites = self.sites
        for m in job.multiplicities: 
            nESD = len(self.ECIbasis[m].ESDs)
            nECSF = len(self.ECIbasis[m].ECSFs)
            self.H[m] = np.zeros((nESD,nESD))
            self.J[m] = np.zeros((nESD,nESD))
            self.K[m] = np.zeros((nESD,nESD))
            self.S[m] = np.zeros((nESD,nESD))
            self.h2[m] = np.zeros((nESD,nESD))
        return
    #----END of ECI.allocate------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

    #----START of ECI.calculate_Fmat------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def calculate_Fmat( self, nucs, mol ):
        F = np.zeros((mol.nao, mol.nao))
        for g in nucs:
            for a in range(g.mol.natm):
                Z, R = g.mol.atom_charge(a) - g.Q[a], g.mol.atom_coord(a)
                mol.set_rinv_orig(R)
                F += Z*mol.intor('int1e_rinv')
        return F
    #----END of ECI.calculate_Fmat------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

    #----START of ECI.calculate_Gtensor------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def calculate_Gtensor(self,moles ):
        starts = {}
        ends = {}
        supermolecule = None
        for mol in moles:
            if not mol in starts.keys():
                starts[mol] = sum( [ m.nbas for m in starts.keys() ] )
                ends[mol] = starts[mol] + mol.nbas 
                if supermolecule == None:
                    supermolecule = mol.copy()
                else:
                    supermolecule = merge_moles( supermolecule, mol )

        G = supermolecule.intor('int2e',
                                shls_slice=( starts[moles[0]], ends[moles[0]], 
                                            starts[moles[1]], ends[moles[1]], 
                                            starts[moles[2]], ends[moles[2]], 
                                            starts[moles[3]], ends[moles[3]] ) )
        #  self.log.print('    Dimension of G-tensor I just calculated: '+str(np.shape(G)))
        return G
    #----END of ECI.calculate_Gtensor------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

    #----START of ECI.calculate_Hmat------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    def calculate_Hmat(self):
        job = self.job
        ECIbasis = self.ECIbasis
        sites = self.sites
        H = self.H
        J = self.J
        K = self.K
        #  self.calculate_Smat()
        #  S = self.S

        ECI_integrals = self.get_ECI_integrals()

        integrals, prefactors  = ECI_integrals
        integrals  = integrals.get( 'ECI_V', None )
        if integrals != None:
            self.log.print(' Calculating ECI V-integrals...')
            for (f,nucs), densities__locs in integrals.items():
                self.log.print('    Site: '+f.label+', Nuclei: '+', '.join([nuc.label for nuc in nucs])+' (# = '+str(len(densities__locs))+')')
                Fmat = self.calculate_Fmat( nucs, f.mol )
                rhos = np.array([ f.rho[d[0].Z][d] for d in densities__locs.keys() ])
                locs = densities__locs.values() 
                values = np.einsum( 'ij,nij->n', Fmat, rhos, optimize=['einsum_path', (0,1)] ) 
                for i, individual_locs in enumerate(locs):
                    for (mult,row,column) in individual_locs:
                        J[mult][row,column] -= values[i]

        integrals, prefactors  = ECI_integrals
        integrals  = integrals.get( 'ECI_J', None )
        if integrals != None:
            self.log.print(' Calculating ECI J-integrals...')
            for (f1,f2), densities1_densities2__locs in integrals.items():
                self.log.print('    Site 1: '+f1.label+', Site 2: '+f2.label+' (# = '+str(len(densities1_densities2__locs))+')')
                locs = densities1_densities2__locs.values()
                rhos1 = np.array([ f1.rho[d1[0].Z][d1] for (d1,d2) in densities1_densities2__locs.keys() ]) 
                rhos2 = np.array([ f2.rho[d2[0].Z][d2] for (d1,d2) in densities1_densities2__locs.keys() ]) 
                if job.ri:
                    auxmol = merge_moles( f1.mol, f2.mol )
                    auxmol.build(basis=job.auxbasis)

                    t1 = time.time()
                    P = auxmol.intor('int2c2e')
                    P = np.linalg.inv(P)
                    t2 = time.time()
                    self.log.print('       Calculation of P-matrix of dim. '+str(P.shape)+' took '+str(round(t2-t1,3))+' sec.')

                    t1 = time.time()
                    calcmol = merge_moles( f1.mol, auxmol )
                    L1 = calcmol.intor('int3c2e', shls_slice=(0, f1.mol.nbas, 0, f1.mol.nbas, f1.mol.nbas, calcmol.nbas))
                    calcmol = merge_moles( f2.mol, auxmol )
                    L2 = calcmol.intor('int3c2e', shls_slice=(0, f2.mol.nbas, 0, f2.mol.nbas, f2.mol.nbas, calcmol.nbas))
                    t2 = time.time()
                    self.log.print('       Calculation of L-tensors of dims. '+str(L1.shape)+' and '+str(L2.shape)+' took '+str(round(t2-t1,3))+' sec.')

                    t1 = time.time()
                    values = np.einsum('nij,ijp,pq,klq,nkl->n', rhos1, L1, P, L2, rhos2, optimize=True )
                    t2 = time.time()
                    self.log.print('       Contraction took '+str(round(t2-t1,3))+' sec.')
                else:
                    G = self.calculate_Gtensor( [f1.mol, f1.mol, f2.mol, f2.mol] ) 
                    values = np.einsum( 'nij,ijkl,nkl->n', rhos1, G, rhos2, optimize=['einsum_path', (0, 1), (0, 1)] )
                for i, individual_locs in enumerate(locs):
                    for (mult,row,column) in individual_locs:
                        J[mult][row,column] += values[i]
            
        integrals, prefactors  = ECI_integrals
        integrals  = integrals.get( 'ECI_K', None )
        if integrals != None:
            self.log.print(' Calculating ECI K-integrals...')
            for (f1,f2), densities1_densities2__locs in integrals.items():
                self.log.print('    Site 1: '+f1.label+', Site 2: '+f2.label+' (# = '+str(len(densities1_densities2__locs))+')')
                locs = densities1_densities2__locs.values()
                rhos1 = np.array([ f1.rho[d1[0].Z][d1] for (d1,d2) in densities1_densities2__locs.keys() ]) 
                rhos2 = np.array([ f2.rho[d2[0].Z][d2] for (d1,d2) in densities1_densities2__locs.keys() ]) 
                if job.Kscreen:
                    auxmol = merge_moles( f1.mol, f2.mol )
                    S = np.abs(auxmol.intor('int1e_ovlp')[:f1.mol.nao,f1.mol.nao:])

                    slices_1 = f1.mol.aoslice_by_atom()
                    aos_to_atoms_1 = {}
                    for i in range(f1.mol.natm):
                        for j in range(slices_1[i][2],slices_1[i][3]):
                            aos_to_atoms_1[j] = i
                    slices_2 = f2.mol.aoslice_by_atom()
                    aos_to_atoms_2 = {}
                    for i in range(f2.mol.natm):
                        for j in range(slices_2[i][2],slices_2[i][3]):
                            aos_to_atoms_2[j] = i

                    atom_pairs = set()
                    rows, cols = np.nonzero(S >= 1e-4)
                    for r, c in zip(rows, cols):
                        atom_pairs.add((aos_to_atoms_1[r],aos_to_atoms_2[c]))
                    atom_pairs = list(atom_pairs)
                    self.log.print('       Found '+str(len(atom_pairs))+' overlapping atom pairs.')

                    if len(atom_pairs) > 0:
                        #  auxmol.build(basis=job.auxbasis)
                        t1 = time.time()
                        values = np.zeros(rhos1.shape[0])
                        maxGs = []
                        for p in atom_pairs:
                            sh_istart, sh_iend, ao_istart, ao_iend = slices_1[p[0]]
                            sh_lstart, sh_lend, ao_lstart, ao_lend = slices_2[p[1]]
                            G = auxmol.intor('int2e',shls_slice=(sh_istart,sh_iend,sh_lstart+f1.mol.nbas,sh_lend+f1.mol.nbas,sh_istart,sh_iend,sh_lstart+f1.mol.nbas,sh_lend+f1.mol.nbas)) 
                            maxGs.append(np.amax(np.abs(G)))
                            values += np.einsum('nij,iljk,nkl->n',rhos1[:,ao_istart:ao_iend,ao_istart:ao_iend], G, rhos2[:,ao_lstart:ao_lend,ao_lstart:ao_lend], optimize=['einsum_path', (0,1), (0,1)])
                        t2 = time.time()
                        self.log.print('       Diagonal contractions took '+str(round(t2-t1,3))+' sec.')
                        t1 = time.time()
                        max_prods = np.sqrt(np.abs(np.outer(maxGs, maxGs)))
                        np.fill_diagonal(max_prods,-1.)
                        pairs1, pairs2 = np.nonzero(max_prods >= 1e-4)
                        self.log.print('       Will do '+str(len(pairs1))+' off-diagonal contractions.')
                        for p1, p2 in zip(pairs1,pairs2):
                            ai, al = atom_pairs[p1]
                            aj, ak = atom_pairs[p2]
                            sh_istart, sh_iend, ao_istart, ao_iend = slices_1[ai]
                            sh_jstart, sh_jend, ao_jstart, ao_jend = slices_1[aj]
                            sh_kstart, sh_kend, ao_kstart, ao_kend = slices_2[ak]
                            sh_lstart, sh_lend, ao_lstart, ao_lend = slices_2[al]
                            slices = (sh_istart,sh_iend,
                                      sh_lstart + f1.mol.nbas,sh_lend + f1.mol.nbas,
                                      sh_jstart, sh_jend,
                                      sh_kstart + f1.mol.nbas, sh_kend + f1.mol.nbas)
                            G = auxmol.intor('int2e',shls_slice=slices) 
                            values += np.einsum('nij,iljk,nkl->n',rhos1[:,ao_istart:ao_iend,ao_jstart:ao_jend], G, rhos2[:,ao_kstart:ao_kend,ao_lstart:ao_lend], optimize=['einsum_path', (0,1), (0,1)])
                        t2 = time.time()
                        self.log.print('       Off-diagonal contractions took '+str(round(t2-t1,3))+' sec.')
                else:
                    G = self.calculate_Gtensor( [f1.mol, f2.mol, f1.mol, f2.mol] ) 
                    values = np.einsum( 'nij,iljk,nkl->n', rhos1, G, rhos2, optimize=['einsum_path', (0, 1), (0, 1)] )
                for i, individual_locs in enumerate(locs):
                    for (mult,row,column) in individual_locs:
                        K[mult][row,column] += values[i]

        integrals, prefactors  = ECI_integrals
        integrals  = integrals.get( 'SCT_V', None )
        if integrals != None:
            self.log.print(' Calculating SCT V-integrals...')
            for (f1,f2,nucs), dysons1_dysons2__locs in integrals.items():
                phis1 = np.array( [ f1.phi[(do1[0].Z,do1[1].Z)][do1] for (do1,do2) in dysons1_dysons2__locs.keys() ] )
                phis2 = np.array( [ f2.phi[(do2[0].Z,do2[1].Z)][do2] for (do1,do2) in dysons1_dysons2__locs.keys() ] )
                locs = dysons1_dysons2__locs.values()
                Tmat = self.merge_moles( f1.mol, f2.mol ).intor('int1e_kin')[0:f1.mol.nao,f2.mol.nao:]  
                Fmat = calculate_Fmat( nucs, self.merge_moles( f1.mol, f2.mol ) )[0:f1.mol.nao,f2.mol.nao:] 
                hmat = Tmat + Fmat
                values = np.einsum( 'ni,ij,nj->n', phis1, hmat, phis2, optimize=['einsum_path', (0,1), (0,1)] )
                for i, individual_locs in enumerate(locs):
                    for (mult,row,column) in individual_locs_prefactors:
                        J[mult][row,column] -= prefactor[(mult,row,column)]*values[i]
                    
        integrals, prefactors  = ECI_integrals
        integrals  = integrals.get( 'SCT_JK', None )
        if integrals != None:
            self.log.print(' Calculating SCT JK-integrals...')
            for (f1,f2,f), dysons1_dysons2_Jdensities_Kdensities__locs in integrals.items():
                phis1 = np.array( [ f1.phi[(do1[0].Z,do1[1].Z)][do1] for (do1,do2,Jdensity,Kdensity) in dysons1_dysons2_Jdensities_Kdensities__locs.keys() ] )
                phis2 = np.array( [ f2.phi[(do2[0].Z,do2[1].Z)][do2] for (do1,do2,Jdensity,Kdensity) in dysons1_dysons2_Jdensities_Kdensities__locs.keys() ] )
                Jrhos = np.array( [ f.rho[density[0].Z][Jdensity] for (do1,do2,Jdensity,Kdensity) in dysons1_dysons2_Jdensities_Kdensities__locs.keys() ] )
                Krhos = np.array( [ f.rho[density[0].Z][Kdensity] for (do1,do2,Jdensity,Kdensity) in dysons1_dysons2_Jdensities_Kdensities__locs.keys() ] )
                locs = dysons1_dysons2_Jdensities_Kdensities__locs.values()
                G = calculate_Gtensor( [ f1.mol, f2.mol, f.mol, f.mol ] )
                GJ = np.einsum('ijkl,nkl->nij', G, Jrhos, optimize=['einsum_path', (0, 1)] )
                GK = np.einsum('iljk,nkl->nij', G, Krhos, optimize=['einsum_path', (0, 1)] )
                values = np.einsum('ni,nj,nij->n', phis1, phis2, GJ - GK, optimize=['einsum_path', (0, 2), (0, 1)] ) 
                for i, individual_locs in enumerate(locs):
                    for (mult,row,column) in individual_locs:
                        J[mult][row,column] += prefactor[(mult,row,column)]*values[i]

        integrals, prefactors  = ECI_integrals
        integrals  = integrals.get( 'SCT_J', None )
        if integrals != None:
            self.log.print(' Calculating SCT J-integrals...')
            for (f1,f2,f), dysons1_dysons2_Jdensities__locs in integrals.items():
                phis1 = np.array( [ f1.phi[(do1[0].Z,do1[1].Z)][do1] for (do1,do2,Jdensity) in dysons1_dysons2_Jdensities__locs.keys() ] )
                phis2 = np.array( [ f2.phi[(do2[0].Z,do2[1].Z)][do2] for (do1,do2,Jdensity) in dysons1_dysons2_Jdensities__locs.keys() ] )
                Jrhos = np.array( [ f.rho[density[0].Z][Jdensity] for (do1,do2,Jdensity) in dysons1_dysons2_Jdensities__locs.keys() ] )
                locs = dysons1_dysons2_Jdensities__locs.values()
                G = calculate_Gtensor( [ f1.mol, f2.mol, f.mol, f.mol ] )
                values = np.einsum( phis1, phis2, G, Jrhos, 'ni,nj,ijkl,nkl->n', optimize=['einsum_path', (2, 3), (0, 2), (0, 1)] ) 
                for i, individual_locs in enumerate(locs):
                    for (mult,row,column) in individual_locs:
                        J[mult][row,column] += prefactor[(mult,row,column)]*values[i]
        #  self.log.print(' Calculating all h2-matrices')
        #  self.calculate_h2mat()
        #  h2 = self.h2
        #self.log.print(' Summing up J-, K- and h2-matrices, adding site energies and VNN to the diagonal, and rotating J-, K-, and H-matrices to the basis of ECSFs...')
        self.log.print(' Summing up J- and K-matrices, adding site energies and VNN to the diagonal, and rotating J-, K-, and H-matrices to the basis of ECSFs...')
        VNN = sum( [ 
                    ( float( f.mol.atom_charge(i) )*float( g.mol.atom_charge(j) )
                    - float( f.mol.atom_charge(i) )*g.Q[j]
                    - float( g.mol.atom_charge(j) )*f.Q[i] 
                     )/np.linalg.norm( f.mol.atom_coord(i) - g.mol.atom_coord(j) )
                    for ( f, g ) in job.active_integrals['J'][(0,0)]
                    for i in range(f.mol.natm) for j in range(g.mol.natm)
                    ] 
                  )
        self.log.print(' Total inter-fragment nuclear-nuclear repulsion (au) = '+str(VNN))

        for m in job.multiplicities:
            J[m] += VNN*np.identity( np.shape(J[m])[0] )
            #H[m] = J[m] - K[m] - h2[m] 
            H[m] = J[m] - K[m] 

            for i, ESD in enumerate( ECIbasis[m].ESDs ):
                for site, state in ESD.site_states.items():
                    Z = state.Z
                    index = site.states[Z].index(state) 
                    H[m][i,i] += site.H[Z][index,index]

            H[m] = H[m] + H[m].T - np.diag( np.diag( H[m] ) )
            J[m] = J[m] + J[m].T - np.diag( np.diag( J[m] ) )
            K[m] = K[m] + K[m].T - np.diag( np.diag( K[m] ) )
            #  h2[m] = h2[m] + h2[m].T - np.diag( np.diag( h2[m] ) )

            H[m] = ECIbasis[m].U.T @ H[m] @ ECIbasis[m].U 
            J[m] = ECIbasis[m].U.T @ J[m] @ ECIbasis[m].U 
            K[m] = ECIbasis[m].U.T @ K[m] @ ECIbasis[m].U 
            #  S[m] = ECIbasis[m].U.T @ S[m] @ ECIbasis[m].U 
            #  h2[m] = ECIbasis[m].U.T @ h2[m] @ ECIbasis[m].U 

            self.log.print(' H-, J-, K-matrices for multiplicity '+str(m)+' in the basis of ECSFs:')
            #for label, mat in zip( ['H', 'J', 'K', 'S', 'h2'], [H,J,K,S,h2] ):
            for label, mat in zip( ['H', 'J', 'K'], [H,J,K] ):
                self.log.print('    '+label+'-matrix:')
                for i in range(len(ECIbasis[m].ECSFs)):
                    self.log.print('        '+' '.join([ f"{mat[m][i,j]: 20.10f}" for j in range( len(ECIbasis[m].ECSFs)) ]) )

            #  dimer = merge_moles( sites[0].mol, sites[1].mol )
            #  SAO = dimer.intor('int1e_ovlp')[ 0:sites[0].mol.nao:, sites[0].mol.nao: ]
            #  O = []
            #  for i, spin in enumerate(['aa','bb']):
                #  rho1 = sites[0].rho[1][(sites[0].aufbau_states[0], sites[0].aufbau_states[0], spin)]
                #  rho2 = sites[1].rho[-1][(sites[1].aufbau_states[0], sites[1].aufbau_states[0], spin)]
                #  O.append(np.einsum( 'ij,kl,il,jk', rho1, rho2, SAO, SAO, optimize=['einsum_path', (0, 2), (0, 1), (0, 1)] ) )
            #  #  k = np.linalg.det(np.array([[10.,np.sqrt(O)],[-np.sqrt(O),18.]]))/180.
            #  k = 1. - O[0] - O[1] + O[0]*O[1]
            #  self.log.print('Overlap aaaa and bbbb = '+str(O[0])+' '+str(O[1]))
            #  self.log.print('Scaling overlap = '+str(k))
        return
    #----END of ECI.calculate_Hmat------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   
    
    def calculate_Pmats(self):
        P = self.P
        for f in self.sites:
            for g in self.sites:
                if not f is g:
                    P[(f,g)] = {}
                    dimer = merge_moles( f.mol, g.mol )
                    S = dimer.intor('int1e_ovlp')[ 0:f.mol.nao:, f.mol.nao: ]
                    for statesf in f.states.values():
                        for statesg in g.states.values():
                            for sf1 in statesf:
                                for sf2 in statesf:
                                    if sf1.Z == sf2.Z: 
                                        for sg1 in statesg:
                                            for sg2 in statesg:
                                                if sg1.Z == sg2.Z:
                                                    p = np.zeros((f.mol.nao,g.mol.nao))
                                                    for sigma in ['a','b']:
                                                        for tau in ['a','b']:
                                                            if (sf1,sf2,sigma+tau) in f.rho[sf1.Z] and (sg1,sg2,tau+sigma) in g.rho[sg1.Z]:
                                                                p += f.rho[sf1.Z][(sf1,sf2,sigma+tau)] @ S @ g.rho[sg1.Z][(sg1,sg2,tau+sigma)] 
                                                    P[(f,g)][(sf1,sf2,sg1,sg2)] = p
        return
                                                    





    def calculate_Smat(self):
        job = self.job
        sites = self.sites
        S = self.S
        self.calculate_Pmats()
        P = self.P
        Nel = float(sum( [ f.mol.nelectron for f in sites ] ) - job.charge) # All Mole object in children have to be build with charge=0
        for m in job.multiplicities:
            ECIbasis = self.ECIbasis[m]
            for i1, ESD1 in enumerate(ECIbasis.ESDs):
                for i2, ESD2 in enumerate(ECIbasis.ESDs[i1:]):
                    O = 0.
                    if ESD1 is ESD2:
                        O  = 1.
                    for f in sites:
                        for g in sites:
                            if not f is g:
                                dimer = merge_moles( f.mol, g.mol )
                                SAO = dimer.intor('int1e_ovlp')[ 0:f.mol.nao:, f.mol.nao: ]
                                sf1 = ESD1.site_states[f]
                                sf2 = ESD2.site_states[f]
                                sg1 = ESD1.site_states[g]
                                sg2 = ESD2.site_states[g]
                                if (sf1,sf2,sg1,sg2) in P[(f,g)]:
                                    O -= np.einsum( 'ij,ij', SAO, P[(f,g)][(sf1,sf2,sg1,sg2)], optimize=['einsum_path', (0, 1)] )/Nel
                    S[m][i1,i1+i2] = O
            S[m] = S[m] + S[m].T - np.diag(np.diag(S[m]))
        return


    def calculate_h2mat(self):
        job = self.job
        sites = self.sites
        h2 = self.h2
        P = self.P
        for m in job.multiplicities:
            ECIbasis = self.ECIbasis[m]
            for f in sites:
                for g in sites:
                    if not f is g:
                        dimer = merge_moles( f.mol, g.mol )
                        T = dimer.intor('int1e_kin')[ 0:f.mol.nao:, f.mol.nao: ] 
                        VNE = -self.calculate_Fmat( sites, dimer )[ 0:f.mol.nao:, f.mol.nao: ]  
                        hFG = T + VNE
                        for i1, ESD1 in enumerate(ECIbasis.ESDs):
                            for i2, ESD2 in enumerate(ECIbasis.ESDs[i1:]):
                                integral = 0.
                                sf1 = ESD1.site_states[f]
                                sf2 = ESD2.site_states[f]
                                sg1 = ESD1.site_states[g]
                                sg2 = ESD2.site_states[g]
                                if (sf1,sf2,sg1,sg2) in P[(f,g)]:
                                    h2[m][i1,i1+i2] += np.einsum( 'ij,ij', hFG, P[(f,g)][(sf1,sf2,sg1,sg2)], optimize=['einsum_path', (0, 1)] )
        return



    def get_ECI_integrals(self):
        job = self.job
        sites = self.sites
        ECIbasis = self.ECIbasis

        ECI_integrals = {}
        def add_integral( k1, k2, k3, loc):
            if k1 in ECI_integrals:
                if k2 in ECI_integrals[k1]:
                    if k3 in ECI_integrals[k1][k2]:
                        ECI_integrals[k1][k2][k3].append(loc)
                    else:
                        ECI_integrals[k1][k2][k3] = [loc]
                else:
                    ECI_integrals[k1][k2] = {k3:[loc]}
            else:
                ECI_integrals[k1] = {k2:{k3:[loc]}}
            return

        prefactors = {}

        for m in job.multiplicities:
            ESDs = ECIbasis[m].ESDs
            relationship = ECIbasis[m].relationships

            #-----Start of relationship[(0,0)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            for pair in relationship[(0,0)]:
                ESD = pair['ESDs'][0]
                index = ESD.index
                # V-integrals
                actives = job.active_integrals['J'][(0,0)]
                for f in sites:
                    nucs = tuple([ g for g in sites if (f,g) in actives or (g,f) in actives ])
                    d = (ESD.site_states[f], ESD.site_states[f], 'tot')
                    add_integral( k1='ECI_V', k2=(f,nucs), k3=d, loc=(m,index,index))
                # J-integrals
                for (f1,f2) in actives:
                    d1 = ( ESD.site_states[f1], ESD.site_states[f1], 'tot' ) 
                    d2 = ( ESD.site_states[f2], ESD.site_states[f2], 'tot' ) 
                    add_integral( k1='ECI_J', k2=(f1,f2), k3=(d1,d2), loc=(m,index,index))
                # K-integrals
                actives = job.active_integrals['K'][(0,0)]
                for (f1,f2) in actives:
                    d1 = ( ESD.site_states[f1], ESD.site_states[f1], 'aa' ) 
                    d2 = ( ESD.site_states[f2], ESD.site_states[f2], 'aa' ) 
                    add_integral( k1='ECI_K', k2=(f1,f2), k3=(d1,d2), loc=(m,index,index))
                    d1 = ( ESD.site_states[f1], ESD.site_states[f1], 'bb' ) 
                    d2 = ( ESD.site_states[f2], ESD.site_states[f2], 'bb' ) 
                    add_integral( k1='ECI_K', k2=(f1,f2), k3=(d1,d2), loc=(m,index,index))
            #-----End of relationship[(0,0)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


            #-----Start of relationship[(0,1)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            for pair in relationship[(0,1)]:
                ESD1, ESD2 = pair['ESDs']
                i1, i2 = ESD1.index, ESD2.index
                f = pair['exciton']
                actives = job.active_integrals['J'][(0,1)] 
                #V-integrals
                nucs = tuple([ g for g in sites if (f,g) in actives or (g,f) in actives])
                d = ( ESD1.site_states[f], ESD2.site_states[f], 'tot' ) 
                if any([ d in rho for rho in f.rho.values()]): 
                    add_integral( k1='ECI_V', k2=(f,nucs), k3=d, loc=(m,i1,i2) )
                # J-integrals
                for (f1,f2) in actives:
                    if f1 is f or f2 is f:
                        d1 = ( ESD1.site_states[f1], ESD2.site_states[f1], 'tot' ) 
                        d2 = ( ESD1.site_states[f2], ESD2.site_states[f2], 'tot' )
                        if any([ d1 in rho for rho in f1.rho.values()]) and any([ d2 in rho for rho in f2.rho.values()]): 
                            add_integral( k1='ECI_J', k2=(f1,f2), k3=(d1,d2), loc=(m,i1,i2) )
                # K-integrals
                actives = job.active_integrals['K'][(0,1)] 
                for (f1,f2) in actives:
                    if f1 is f or f2 is f:
                        d1 = ( ESD1.site_states[f1], ESD2.site_states[f1], 'aa' ) 
                        d2 = ( ESD1.site_states[f2], ESD2.site_states[f2], 'aa' )
                        if any([ d1 in rho for rho in f1.rho.values()]) and any([ d2 in rho for rho in f2.rho.values()]): 
                            add_integral( k1='ECI_K', k2=(f1,f2), k3=(d1,d2), loc=(m,i1,i2) )
                        d1 = ( ESD1.site_states[f1], ESD2.site_states[f1], 'bb' ) 
                        d2 = ( ESD1.site_states[f2], ESD2.site_states[f2], 'bb' )
                        if any([ d1 in rho for rho in f1.rho.values()]) and any([ d2 in rho for rho in f2.rho.values()]): 
                            add_integral( k1='ECI_K', k2=(f1,f2), k3=(d1,d2), loc=(m,i1,i2) )
                        d1 = ( ESD1.site_states[f1], ESD2.site_states[f1], 'ab' ) 
                        d2 = ( ESD1.site_states[f2], ESD2.site_states[f2], 'ba' )
                        if any([ d1 in rho for rho in f1.rho.values()]) and any([ d2 in rho for rho in f2.rho.values()]): 
                            add_integral( k1='ECI_K', k2=(f1,f2), k3=(d1,d2), loc=(m,i1,i2) )
                        d1 = ( ESD1.site_states[f1], ESD2.site_states[f1], 'ba' ) 
                        d2 = ( ESD1.site_states[f2], ESD2.site_states[f2], 'ab' )
                        if any([ d1 in rho for rho in f1.rho.values()]) and any([ d2 in rho for rho in f2.rho.values()]): 
                            add_integral( k1='ECI_K', k2=(f1,f2), k3=(d1,d2), loc=(m,i1,i2) )
            #-----End of relationship[(0,1)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

            #-----Start of relationship[(0,2)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            for pair in relationship[(0,2)]:
                ESD1, ESD2 = pair['ESDs']
                i1, i2 = ESD1.index, ESD2.index
                f1, f2 = pair['excitons']
                # J-integrals
                actives = job.active_integrals['J'][(0,2)] 
                if (f1,f2) in actives:
                    d1 = (ESD1.site_states[f1], ESD2.site_states[f1], 'tot')
                    d2 = (ESD1.site_states[f2], ESD2.site_states[f2], 'tot')
                    if any([ d1 in rho for rho in f1.rho.values()]) and any([ d2 in rho for rho in f2.rho.values()]): 
                        add_integral( k1='ECI_J', k2=(f1,f2), k3=(d1,d2), loc=(m,i1,i2) )
                # K-integrals
                actives = job.active_integrals['K'][(0,2)] 
                if (f1,f2) in actives:
                    d1 = ( ESD1.site_states[f1], ESD2.site_states[f1], 'aa' ) 
                    d2 = ( ESD1.site_states[f2], ESD2.site_states[f2], 'aa' )
                    if any([ d1 in rho for rho in f1.rho.values()]) and any([ d2 in rho for rho in f2.rho.values()]): 
                        add_integral( k1='ECI_K', k2=(f1,f2), k3=(d1,d2), loc=(m,i1,i2) )
                    d1 = ( ESD1.site_states[f1], ESD2.site_states[f1], 'bb' ) 
                    d2 = ( ESD1.site_states[f2], ESD2.site_states[f2], 'bb' )
                    if any([ d1 in rho for rho in f1.rho.values()]) and any([ d2 in rho for rho in f2.rho.values()]): 
                        add_integral( k1='ECI_K', k2=(f1,f2), k3=(d1,d2), loc=(m,i1,i2) )
                    d1 = ( ESD1.site_states[f1], ESD2.site_states[f1], 'ab' ) 
                    d2 = ( ESD1.site_states[f2], ESD2.site_states[f2], 'ba' )
                    if any([ d1 in rho for rho in f1.rho.values()]) and any([ d2 in rho for rho in f2.rho.values()]): 
                        add_integral( k1='ECI_K', k2=(f1,f2), k3=(d1,d2), loc=(m,i1,i2) )
                    d1 = ( ESD1.site_states[f1], ESD2.site_states[f1], 'ba' ) 
                    d2 = ( ESD1.site_states[f2], ESD2.site_states[f2], 'ab' )
                    if any([ d1 in rho for rho in f1.rho.values()]) and any([ d2 in rho for rho in f2.rho.values()]): 
                        add_integral( k1='ECI_K', k2=(f1,f2), k3=(d1,d2), loc=(m,i1,i2) )
        #-----End of relationship[(0,2)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

        #-----Start of relationship[(1,0)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        Jactives = job.active_integrals['J'][(1,0)] 
        Kactives = job.active_integrals['K'][(1,0)] 
        for pair in relationship[(1,0)]:
            ESD1, ESD2 = pair['ESDs']
            i1, i2 = ESD1.index, ESD2.index
            loc = (m,i1,i2)
            d, a = pair['donor'], pair['acceptor']

            Jspectators, Kspectators = [], []
            for f in sites:
                if (d,a,f) in Jactives:
                    Jspectators.append(f)
                if (d,a,f) in Kactives:
                    Kspectators.append(f)
            if len(Jspectators) == 0 and len(Kspectators) == 0: continue

            if d.index < a.index:
                f1, f2 = d, a
                main_less1 = ESD2.site_states[d]
                main_more1 = ESD1.site_states[d]
                main_less2 = ESD1.site_states[a]
                main_more2 = ESD2.site_states[a]
            else:
                f1, f2 = a, d
                main_less1 = ESD1.site_states[a]
                main_more1 = ESD2.site_states[a]
                main_less2 = ESD2.site_states[d]
                main_more2 = ESD1.site_states[d]

            main_do1, main_do2 = None, None
            for spin in ['a', 'b']:
                if (main_more1, main_less1, spin) in f1.phi[(main_more1.Z,main_less1.Z)]:
                    main_do1 = (main_more1, main_less1, spin) 
                    main_spin1 = spin
                if (main_more2, main_less2, spin) in f2.phi[(main_more2.Z,main_less2.Z)]:
                    main_do2 = (main_more2, main_less2, spin) 
                    main_spin2 = spin

            if not loc in prefactors: 
                phase = sum([ f.mol.nelectron - ESD2.site_states[f].Z for f in sites if f.index > f1.index and f.index <= f2.index ])
                self.log.print('ESD1 = '+repr(ESD1))
                self.log.print('ESD2 = '+repr(ESD2))
                self.log.print('main_more1 = '+main_more1.symbol())
                self.log.print('main_more2 = '+main_more2.symbol())
                prefactors[loc] = (-1.)**phase/main_more1.C['subnorm']/main_more2.C['subnorm']

            # V-integral and J and K integrals with other state densities of other spectators
            if main_spin1 == main_spin2 and main_do1 != None and main_do2 != None:
                if len(Jspectators) > 0: add_integral( k1='SCT_V', k2=(f1,f2,Jspectators), k3=(main_do1,main_do2), loc=loc )
                for f in Jspectators:
                    if f is f1 or f is f2: continue # This is gonna be added later
                    s = ESD1.site_states[f]
                    Jrho = (s,s,'tot') 
                    add_integral( k1='SCT_J', k2=(f1,f2,f), k3=(main_do1, main_do2, Jrho), loc=loc )
                for f in Kspectators:
                    if f is f1 or f is f2: continue # This is gonna be added later
                    s = ESD1.site_states[f]
                    Krho = (s,s,main_spin2 + main_spin1)
                    add_integral( k1='SCT_K', k2=(f1,f2,f), k3=(main_do1, main_do2, Krho), loc=loc )

            # J and K integrals with donor and acceptor being spectators
            if main_do2 != None: 
                for less1 in f1.states[main_less1.Z]:
                    for spin1 in ['a','b']:
                        do1 = (main_more1,less1,spin1) 
                        if do1 in f1.phi[(main_more1.Z,main_less1.Z)]: break
                        do1 = None
                    if do1 != None:
                        if spin1 == main_spin2:
                            Jrho = (less1,main_less1,'tot') 
                            if not Jrho in f1.rho[main_less1.Z]: Jrho = None
                        Krho = (less1, main_less1, main_spin2 + spin1)
                        if not Krho in f1.rho[main_less1.Z]: Krho = None 

                        if Jrho != None and Krho != None and (d,a,f1) in Jspectators and (d,a,f1) in Kspectators:
                            add_integral( k1='SCT_JK', k2=(f1,f2,f1), k3=(do1,main_do2,Jrho,Krho), loc=loc )
                        elif Jrho != None and (d,a,f1) in Jspectators:
                            add_integral( k1='SCT_J', k2=(f1,f2,f1), k3=(do1,main_do2,Jrho), loc=loc )
                        elif Krho != None and (d,a,f1) in Kspectators:
                            add_integral( k1='SCT_K', k2=(f1,f2,f1), k3=(do1,main_do2,Krho), loc=loc )

            if main_do1 != None: 
                for less2 in f2.states[main_less2.Z]:
                    for spin2 in ['a','b']:
                        do2 = (main_more2,less2,spin2) 
                        if do2 in f2.phi[(main_more2.Z,main_less2.Z)]: break
                        do2 = None
                    if do2 != None:
                        if spin2 == main_spin1:
                            Jrho = (main_less2, less2, 'tot') 
                            if not Jrho in f2.rho[main_less2.Z]: Jrho = None
                        Krho = (main_less2, less2, spin2 + main_spin1)
                        if not Krho in f2.rho[main_less2.Z]: Krho = None 

                        if Jrho != None and Krho != None and (d,a,f2) in Jspectators and (d,a,f2) in Kspectators:
                            add_integral( k1='SCT_JK', k2=(f1,f2,f2), k3=(main_do1,do2,Jrho,Krho), loc=loc )
                        elif Jrho != None and (d,a,f2) in Jspectators:
                            add_integral( k1='SCT_J', k2=(f1,f2,f2), k3=(main_do1,do2,Jrho), loc=loc )
                        elif Krho != None and (d,a,f2) in Kspectators:
                            add_integral( k1='SCT_K', k2=(f1,f2,f2), k3=(main_do1,do2,Krho), loc=loc )
        #  #-----End of relationship[(1,0)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

        #-----Start of relationship[(1,1)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        Jactives = job.active_integrals['J'][(1,1)] 
        Kactives = job.active_integrals['K'][(1,1)] 
        for pair in relationship[(1,1)]:
            ESD1, ESD2 = pair['ESDs']
            i1, i2 = ESD1.index, ESD2.index
            loc = (m,i1,i2)
            d, a, e = pair['donor'], pair['acceptor'], pair['exciton']

            Jon = (d,a,e) in Jactives
            Kon = (d,a,e) in Kactives
            if not Jon and not Kon: continue

            if d.index < a.index:
                f1, f2 = d, a
                less1 = ESD2.site_states[d]
                more1 = ESD1.site_states[d]
                less2 = ESD1.site_states[a]
                more2 = ESD2.site_states[a]
                es1 = ESD1.site_states[e]
                es2 = ESD2.site_states[e]
            else:
                f1, f2 = a, d
                less1 = ESD1.site_states[a]
                more1 = ESD2.site_states[a]
                less2 = ESD2.site_states[d]
                more2 = ESD1.site_states[d]
                es1 = ESD2.site_states[e]
                es2 = ESD1.site_states[e]

            do1, do2 = None, None
            for spin in ['a', 'b']:
                if (more1, less1, spin) in f1.phi[(more1.Z,less1.Z)]:
                    do1 = (more1, less1, spin) 
                    spin1 = spin
                if (more2, less2, spin) in f2.phi[(more2.Z,less2.Z)]:
                    do2 = (more2, less2, spin) 
                    spin2 = spin
            if do1 == None or do2 == None: continue

            if not loc in prefactors: 
                phase = sum([ f.mol.nelectron - ESD2.site_states[f].Z for f in sites if f.index > f1.index and f.index <= f2.index ])
                prefactors[loc] = (-1.)**phase/more1.C['subnorm']/more2.C['subnorm']

            # V-integral and J and K integrals with other state densities of other spectators
            Jrho = (es1,es2,'tot')  
            if Jon and spin1 == spin2 and Jrho in e.rho[s1.Z]:
                add_integral( k1='SCT_J', k2=(f1,f2,e), k3=(do1, do2, Jrho), loc=loc )

            Krho = (es1,es2,spin1+spin2)  
            if Kon and Krho in e.rho[s1.Z]: 
                add_integral( k1='SCT_K', k2=(f1,f2,e), k3=(do1, do2, Krho), loc=loc )
        #-----End of relationship[(1,1)]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        return ECI_integrals, prefactors

    def calculate_eigenstates( self ):
        job = self.job
        ECIbasis = self.ECIbasis
        for m in job.multiplicities:
            nCSF = len(ECIbasis[m].ECSFs)
            #  H = np.linalg.inv(self.S[m]) @ self.H[m]
            H = self.H[m]
            self.E[m], self.Psi['ECSF'][m] = np.linalg.eigh( H ) 
            #  sort = np.argsort(self.E[m])
            #  self.E[m] = self.E[m][sort]
            #  self.Psi['ECSF'][m][:,:] = self.Psi['ECSF'][m][:,sort] 
            for i in range(nCSF):
                state = self.Psi['ECSF'][m][:,i] 
                if state[np.argmax(np.abs(state))] < 0.: self.Psi['ECSF'][m][:,i] *= -1.
            self.Psi['ESD'][m] = self.ECIbasis[m].U @ self.Psi['ECSF'][m]
            #  self.log.print(' Full-systems states for multiplicity '+str(m)+' in the basis of ECSFs:')
            #  for i in range(nCSF):
                #  sort = np.flip(np.argsort( np.abs(self.Psi['ECSF'][m][:,i]) ))
                #  self.log.print('    State '+str(i)+' = '+' '.join([ f"{self.Psi['ECSF'][m][sort[j],i]: 15.10f}"+' '+repr(ECIbasis[m].ECSFs[sort[j]]) for j in range(nCSF)] ))


            #  self.E[m], self.Psi['ECSF'][m] = np.linalg.eigh( self.H[m] )

            #  nESD = len(ECIbasis[m].ESDs)
            #  sigma, D = np.linalg.eigh(self.S[m])
            #  A = D
            #  for i in range(nESD):
                #  A[:,i] /= np.sqrt(sigma[i])
            #  H = A.T @ self.H[m] @ A 
            #  self.E[m], self.Psi['ESD'][m] = np.linalg.eig( H )
            #  self.Psi['ESD'][m] = A @ self.Psi['ESD'][m] 

            #  print('ECI energies = ',np.amin(self.E[m]))
            #  self.Psi['ESD'][m] = self.ECIbasis[m].U.T @ self.Psi['ECSF'][m]
            #  print('ECI wavefunctions = ', self.Psi['ESD'][m])
            #  print('Smat = ', self.S[m])
            #  exit()

            #  nstates = len( ECIbasis[m].ECSFs)
            #  self.diagnostics[m] = np.zeros( ( max(job.ct_level), max(job.eci_level), nstates ) )
            #  C2 = np.zeros( nstates )
            #  C4 = np.zeros( nstates )
            #  for i, ECSF in enumerate( self.ECIbasis[m].ECSFs ):
                #  self.diagnostics[m][ECSF.ct_level,ECSF.eci_level,:] += self.Psi['ECSF'][i,:]**2
                #  C2 += self.Psi['ECSF'][i,:]**2
                #  C4 += self.Psi['ECSF'][i,:]**4
            #  self.PR[m] = np.divide(C2,C4)
        return

    def calculate_properties(self):
        if 'dm' in self.job.properties: self.calculate_mu()
        return

    def calculate_mu(self):
        job = self.job
        sites = self.sites

        for m in job.multiplicities:
            ECIbasis = self.ECIbasis[m]
            ESDs = ECIbasis.ESDs
            nESD = len(ESDs)
            self.mu[m] = np.zeros((3, nESD, nESD))
            for pair in ECIbasis.relationships[(0,0)]:
                ESD = pair['ESDs'][0]
                index = pair['indices'][0]
                for f, s in ESD.site_states.items():
                    self.mu[m][:,index,index] += f.mu[s.Z][(s,s)]
            for pair in ECIbasis.relationships[(0,1)]:
                ESD1, ESD2 = pair['ESDs']
                i1, i2 = pair['indices']
                f = pair['exciton']
                Z = ESD1.site_states[f].Z
                if (ESD1.site_states[f], ESD2.site_states[f]) in f.mu[Z]: 
                    self.mu[m][:,i1, i2] = f.mu[Z][(ESD1.site_states[f], ESD2.site_states[f])]
            # TODO: Add relationships[(1,0)]. This is the only remaining non-zero within SOA 
            for x in range(3):
                self.mu[m][x,:,:] = self.mu[m][x,:,:] + self.mu[m][x,:,:].T - np.diag( np.diag( self.mu[m][x,:,:] ) )
            self.mu[m] = np.einsum('ik,xkl,lj->xij', self.Psi['ESD'][m].T, self.mu[m], self.Psi['ESD'][m], optimize=['einsum_path', (0, 1),(0, 1)])
        return

    def print_states(self):
        job = self.job
        ECIbasis = self.ECIbasis
        E0 = self.E[1][0]
        self.log.print(' Ground-state energy = '+str(E0))
        for m in job.multiplicities:
            nCSF = len(ECIbasis[m].ECSFs)
            self.log.print(' Full-systems states for multiplicity '+str(m)+' in the basis of ECSFs:')
            for i in range(nCSF):
                sort = np.flip(np.argsort( np.abs(self.Psi['ECSF'][m][:,i]) ))
                wf = ' '.join([ f"{self.Psi['ECSF'][m][sort[j],i]: 15.10f}"+' '+repr(ECIbasis[m].ECSFs[sort[j]]) for j in range(nCSF)] ) 
                Eex = self.E[m][i] - E0
                f = 2./3.*Eex*np.linalg.norm(self.mu[m][:,0,i])**2 
                self.log.print(f" State {i}: Eex (eV) = {Eex*27.2114: 10.5f} | f = {f: 10.5f} | Psi = {wf}")












        
#----END ECI------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------   

