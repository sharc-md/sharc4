

Fortran code:
- Laser field (Granucci paper, Thachuk paper): radiative/nonradiative hops
- other decoherence schemes (see, e.g., Prezhdo JPCL review)                                            DONE
- adjust_phases from largest element, not from diagonal
- output.dat format, array info not in (list-based) header, triblock-matrices
- IMPORTANT: "no_grad_correct" with "ekin_correct par_nac" produces NaNs and does not work              DONE?
- implement augmented FSSH of Subotnik                                                                  DONE
- implement reflection afer frustrated hops                                                             DONE
- property (1d and 2d) arrays for saving arbitary data along with the trajectory                        DONE
- IMPORTANT: fix crash if properties in QM.out have different number than input                         DONE
- update cwd after restart
- write only every nth step (keyword "output_per_nth_step")
- write restart only at finish (keyword "norestart_per_step" "restart_per_step")
- option for NO NUCLEAR MOTION: run QM without gradients at t=0 (can be omitted by commenting call from runQM.sh and copying QM.out from initial conditions), then simply reuse (no gradients and overlap are read)



Catch SIGINT during write_restart



Important:
- complex-valued NACs after trafo


Makefile:
- output.f90 needs to be compiled every time, so that the build info is always up-to-date               DONE


Tutorial:
- mark background infos                                                                                 refs to manual
- state that the example figures could also look different (different compilers, etc)                   DONE
- switch the tutorial to MOLCAS                                                                         DONE


Manual:
- diagnostics.py                DONE
- elaborate more on analysis    DONE (partially)
- essdyn and nma                DONE
- ADF interface                 DONE
- MOLPRO interface              DONE
- update all interface sections, point to commented input files in examples/            DONE


Initial condition generation:
- script for extracting random geometries from trajectories (from/to timestep, which trajectories, ...)         DONE
- script for setting up scattering initial conditions (merge two initconds files with Wigner distributions, setting translational and rotational shift and relative translational and rotational velocities)
- script for setting up initconds from MD data                                  DONE


Diagnostics tool:                       DONE
    - Check trajectories for 
        * total energy conversion (changes per time step, and overall changes), 
        * discontinuities in the potential energies/kinetic energy, 
        * crashes/normal termination, 
        * missing files (output, is it restartable?), 
        * total population (should not be necessary with our propagators),
        * intruder states
        * TODO: also unreasonable hops?
    - find maximum usable time for each trajectory
- check wall clock times                                        DONE
- if start of current step and current time is very different (e.g., crashed trajectories)              DONE


Python:
- question(): add comma-separated lists         DONE
- class for understanding ranges:
  for example:
        s = "2,5,7-9,12"
        ranges = (x.split("-") for x in s.split(","))
        print [i for r in ranges for i in range(int(r[0]), int(r[-1]) + 1)]
- delete all with statements


excite.py:
- state print if diagonal picture               DONE


geo.py:
- only convert (string->float) lines that are requested


LVC interface:
- add a setup_LVC.py and a LVC_input.py to have a workflow to generate models           DONE
- write Uold.txt to savedir properly                    


Analytical interface:
- write old geometry to savedir properly



ADF interface:
- bug: excited-state diagonal dipole moments are not read correctly (for >=2017.208 mode)       DONE
- spin-flip TDDFT


COLUMBUS interface:
- parallel jobs


MOLPRO interface:
- parallel MOLPRO runs with scheduling from ADF interface
- gradaccumax/default into template file                        DONE
- rootpad for mults with zero roots
- MOLPRO2105?


MOLCAS interface:
- state-averaging with zero weight extra states         DONE
- cleanup keyword                                       DONE
- readcienergy from RASSI output
- RASSCF capabilities (i.e., RAS1, RAS2, RAS3)
- gradaccumax/default into template file                DONE
- backup keyword
- MPI support


diagnostics.py:
- explanation of settings (help dialog)                 DONE
- infinite lines bug                                    DONE (partially)



Setup:
- on the fly Dyson norms                                DONE
- on the fly Theodore                                   DONE
- excite.py: initial state different from S0            DONE
- excite.py: setup a diabatic state                     DONE
- setup calcullations with reference overlaps           DONE


Analysis:
- TR spectra generation from trajectory data            DONE
- TR spectra from a posteriori calculations             implement passive_sharc.x


  
Test suite:                                             DONE
- adjust to new MOLCAS interface
- adjust to new MOLPRO interface
- RICC2, ADF, check COLUMBUS


setup_*.py:
- add interface info about select_directly capabilities



Introduce wfoverlaps to suite
- make $SHARC/wfoverlap.x the default path in setup scripts/interfaces          DONE




wfoverlaps:
- get Python code to compute AO overlaps (think about ordering stuff...)
  => PySCF or PyQuante for example...
  => MO coefficients from Molden File (enough digits!) for consistent ordering


collector:
- summing(X): sum up all X columns if multiple are collected (for each trajectory)



trajana_*.py:
- merge the two scripts
- redesign the time interval setup      DONE



Interfaces:
- choose alpha and beta spins cleverly for efficient Dyson calculations                 DONE
- ALL interfaces should write to savedir some info about the status of the files (i.e., to which time step the new and old files correspond! Otherwise, the interface cannot know whether it should moveToOld at restarts.
- always do phases if overlaps requested



wigner.py:
- Husimi distribution DOI: 10.1088/1751-8113/40/20/012
- Wigner distribution in internal coordinates (???)
- project out stiff modes from MD snapshots and replace by Wigner-sampled values



Interfaces:
- select at least 100 determinants (plus the 0.999 thresholding)


excite.py:
- run frozen-nuclei dynamics with laser field for initial states
  => this needs a way to communicate the initial coefficients to setup_traj.py (new data section in initconds maybe...)


ADF_input.py:
- rework
- separate numbers of singlets and triplets, include GS in counting

COLUMBUS:
- write a colinp_advisor.py script



MOLPRO:
- bugfix for saveAOovl and the other routine that does the same thing (detection of formatting, see Email from Andrew Cooksy)



File IO with named pipe (might be useful to write output.dat directly to a zipped file):
    program testfifo
    implicit none
    integer:: i,j,k,io,unit,iostat
    character(len=30)::File,filename
    character(len=600)::Instruction
    write(*,*)Name of the xz file ?"
    read(*,*)filename
    !//Create a named pipe//
    call EXECUTE_COMMAND_LINE("rm -f MyUnCompressedFile ;mkfifo MyUnCompressedFile")
    !//Open a connection to it//
    open(11,file="MyUnCompressedFile",iostat=iostat)
    !//Write decompression instruction//
    write(Instruction,'(a,a,a)')"(xz -dc  ",filename," >MyUnCompressedFile; echo \x4 >MyUnCompressedFile )"
    !//Execute//
    call EXECUTE_COMMAND_LINE(Instruction)
    !//Execute a normal reading loop//
    do
    read(11,*,iostat=io)i,j,k
    if(io/=0)exit
    write(*,*)i,j,k
    end do
    !//remove named pipe//
    write(Instruction,'(a)')"( rm -f MyUnCompressedFile)"
    CALL EXECUTE_COMMAND_LINE(Instruction)
    end program testfifo